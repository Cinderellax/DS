# 数据结构

## 0. 常用数据结构基本操作（）

待写          

## 1.绪论

### 1.1基本概念	

​	数据结构的**基本单位**是**数据元素**。

​	数据结构的**最小单位**是**数据项**。

​	**数据对象**：具有相同性质的数据元素的集合。

​	**抽象数据类型（ADT）**：一个数学模型以及定义在该模型上的一组操作。（包括：**数据对象，数据关系，基本操作**），可以用来定义一个完整的数据结构。

​	**数据结构**：相互之间存在一种或多种特定**关系**的**数据元素**的**集合**（**数据对象，数据关系**）。

​	**数据结构三要素**：

​		1.**逻辑结构**：

​			（1）线性结构：

​					一般线性表，受限线性表（栈，队列，串），数组，广义表

​			（2）非线性结构；

​					集合，树形结构，图状结构

​		2.**存储结构**

​			（1）顺序存储

​			（2）链式存储

​			（3）索引存储

​			（4）散列存储

​		3.**数据的运算**

​			运算的定义：针对逻辑结构

​			运算的实现：针对存储结构

### 1.2 算法

#### 	1.2.1 算法的基本概念

​		算法是对特定问题求解步骤的一种描述。

​		算法的**特点**：**（1）有穷性（2）确定性（3）可行性（4）输入>=0（5）输出>0**

​		算法'好'的目标：（1）正确性（2）可读性（3）健壮性（4）效率与低存储量

#### 	1.2.2 算法效率的度量

​		**时间复杂度**：**算法问题规模n的函数**，与**执行时间**成**正比**。

​				不仅依赖于**问题的规模n**，也取决于待**输入数据的性质**

​				求法：**公式递推**或者**求和**。

​		**空间复杂度**：

​				算法**原地工作**：辅助空间是**常量**。



## 2.线性表

### 2.1 线性表的定义

​	 线性表（**逻辑结构**）具有**相同数据类型**的n个**数据元素**的**有限**序列。

​	线性表有两个**存储结构**：**顺序表，链表**。

### 2.2 顺序表

#### 	2.2.1 顺序表定义

​			表中元素的逻辑结构与物理结构**相同**。

​			最主要的特点是**随机访问**。 

#### 	2.2.2 顺序表基本操作

​			（1）插入**（$1\le i\le n+1$）**

​				每次移动：**n-i+1**个元素

​				平均次数：$\sum ^{n+1} _{i=1} \frac {1}{n+1} (n-i+1)=\frac {n}{2}$

​			（2）删除**（$1\le i\le n$）**

​				每次移动：**n-i**个元素

​				平均次数：$\sum ^{n} _{i=1} \frac {1}{n} (n-i)=\frac {n-1}{2}$

​			（3）**按值**查找（**顺序查找**）

​				每次查找：i

​				平均次数：$\sum ^{n} _{i=1} \frac {1}{n} *i=\frac {n+1}{2}$

​				时间复杂度：O(n)

​			（4）查找（有下标，普通）

​				1（随机存取）

### 2.3 链表

​	不要求逻辑上相邻的两个元素在物理上也相邻。

#### 	2.3.1 定义

​		头结点的作用是为了**方便运算的实现**。

#### 	2.3.2 基本操作

​		头插法，尾插法

### 2.4 总结

| T(n)                 | 删除最后 | 删除最前 | 最后插入 | 最前插入 |
| -------------------- | -------- | -------- | -------- | -------- |
| 单链表               | O(n)     | O(1)     | O(n)     | O(1)     |
| 循环单链表（头指针） | O(n)     | O(n)     | O(n)     | O(n)     |
| 循环单链表（尾指针） | O(n)     | O(1)     | O(1)     | O(1)     |
| 双链表（头指针）     | O(n)     | O(1)     | O(n)     | O(1)     |
| 双链表（尾指针）     | O(1)     | O(n)     | O(1)     | O(n)     |
| 双链表（头尾指针）   | O(1)     | O(1)     | O(1)     | O(1)     |
| 循环双链表           | O(1)     | O(1)     | O(1)     | O(1)     |

| T(n)             | 顺序表       | 链表     |
| :--------------- | ------------ | -------- |
| 插入             | O(n)         | O(1)     |
| 删除             | O(n)         | O(1)     |
| 按值查找（有序） | O($\log n$)  | O(n)     |
| 按值查找（无序） | O(n)         | O(n)     |
| 随机查找         | O(1)         | O(n)     |
| 排序             | O($n\log n$) | O($n^2$) |

注：若未知链表的结点位置，则需先查找后再插入（删除）。

### 2.5 练习

​	1.链表的每个结点都恰好有一个指针。	错     双链表有两个

​	2.顺序存储结构属于静态结构，链式存储结构属于动态结构。   错    顺序存储也可动态分配

​	3.判断带头结点的单循环链表L仅有一个元素结点的条件是    L->next->next=L&&L->next!=L

​	4.判断。。。双循环。。。。。  L->next->next=L&&L->prior->prior=L&&L->next!=L

​	5.带头结点的双循环链表为空的条件是 L->next=L&&L->prior=L

​	6.逆转链表的算法实现

​	7.对单链表中元素按插入方法排序

​	8.在顺序表A[m+n]中有A1[m]和A2[n],将A2放在A1前。

​		先全部逆序，再分别逆序前n个和后m个。

​	ps:思考将顺序表中的元素左移P个位置，方法同上。

​	9.找到顺序表中的元素，个数$> n/2$ 

​		(1)依次扫描每个数，将扫描的数放入c中，若下一个数与c相同，则count++,否则count--，当count==0时，将遇到的下一个元素放入c中，count=1,继续。

​		(2)再扫描一次数组，若c出现的次数大于n/2则为主元素。

​	10.编写算法找到两个单链表的公共结点。

​		大小分别为m,n,(m>n)，m-n=k,则L1从L1+k处开始走，L2从L2处开始走，两者相等则当前以及后面的结点为公共结点。

​	11.定位到链表中倒数k个的结点。

​		双指针。

​	12.删除链表中绝对值相等的点，|data|<n

​		类似哈希表的用法，以空间换时间。

​	13.将一个升序单链表和一个降序单链表合并为一个有序链表，要求算法时间复杂度为O(m+n)。

​		降序链表头插法逆序后，两个升序链表合并，时间复杂度为max(m,n),则总时间复杂度为O(m+n)。

​	14.逆向输出不带头结点的单向链表的数据的递归算法。

​		直接递归。

​	15.建立双向链表实现二进制数的加减，注意溢出和进位。

​		双向链表，进位则增加前面的节点。

​	16.给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。

​		链表长度为N，将第N/2个结点作为根节点，并以该节点划分链表为左右两个链表，将左边链表的中间节点作为左节点，右链表的中间节点作为右节点，递归执行。

​	17.给定一个链表，

​		（1）判断链表中是否有环。

​		（2）若有环，求环的长度

​		（3）求开始入环的第一个节点

​		解：1.双指针，一个跑一步，一个跑两步，有环则会相遇，否则快的会跑到null,为尾节点。

​			2.快指针为s，慢指针为q，则当两者相遇时，快指针停在当前位置，慢指针继续走，相遇时走过的步数为环的长度。

​			3.接1题，两者相遇时，慢指针从当前位置每次一步走，快指针从链表头位置每次一步的走，两者再次相遇的位置节点为入环的第一个节点。			

​	18.请判断一个链表是否为回文链表。

​		解：思路1：使用栈

​			思路2：双指针，找到中间节点，将中间节点后面的节点反转，从变形链表的两头向中间靠近，依次对比节点，两指针相遇则成立。

​	19.给定一个整数数组，你需要寻找一个 连续的子数组 ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。

​		解：两个标志，一个记录第一次出现非升序的下标，另一个记录最后一次非升序的下标。	

​	20.有两种特殊字符。第一种字符可以用一比特 0 来表示。第二种字符可以用两比特( 10 或 11 )来表示。

现给一个由若干比特组成的字符串。问最后一个字符是否必定为一个一比特字符。给定的字符串总是由0结束。

示例 1:

输入:
bits = [1, 0, 0]
输出: True
解释:
唯一的编码方式是一个两比特字符和一个一比特字符。所以最后一个字符是一比特字符。

示例 2:

输入:
bits = [1, 1, 1, 0]
输出: False

​		解：一个指针从前往后走，遇到1就走两步，遇到0就走一步，看是否会走到n-1的位置。



## 3.栈和队列

### 3.1 栈

#### 3.1.1 栈的基本概念

​	逻辑结构：**线性表**（**操作受限**）

​	存储结构：1.顺序栈 2.链栈

​	数据运算：**先进后出**(**LIFO**)

#### 3.1.2 栈的顺序存储结构

​	1.顺序存储结构代码描述：

```c
#define Maxsize 50
typedef struct{
    Elemtype data[Maxsize];
    int top;
}SqStack;
```

​	栈顶指针：S.top，**初始时**设置**S.top=-1**；栈顶元素：S.data[S.top];

​	进栈操作：1.**判断栈满(S.top==MaxSize-1)** 2.**top++** 3.  S.data[S.top]=x

​	出栈操作：1.**判断栈空(S.top==-1)** 2.x=S.data[S.top] 3.**top--**

​	栈长：**S.top+1**

​	2.**共享栈**

​		栈顶指针(**初始**)：**top0=-1,top1=Maxsize**

​		进栈操作：1.**判断栈满(top1-top0=1)** ； **top0++** ; 赋值

 				   2.**判断栈满(top1-top0=1)** ； **top1--** ; 赋值

​		出栈操作：1.**判断栈空(top0==-1)** ； 赋值 ； **top0--**

​				   2.**判断栈空(top1==Maxsize)** ； 赋值 ； **top1++**

#### 3.1.3 链栈

​	采用链式存储的栈称为链栈，链栈的**优点**是便于**多个栈共享存储空间**和**提高其效率**，且**不存在栈满上溢**的情况。

​	**多个栈**一般采用链栈的方式。

#### 3.1.4 考点

​	n个不同元素进栈，出栈序列的数量

​	**卡特兰数**：
$$
\frac{1}{n+1} C ^{n} _{2n}=\frac{1}{n+1} \frac{(2n)!}{n!*n!}
$$
​	若$X_i$已经出栈，则前面尚未出栈的元素一定逆置有序的出栈。

### 3.2 队列

#### 3.2.1 队列的基本概念

​	队列也是一种操作受限的线性表，先进先出(FIFO)。

#### 3.2.2 队列的顺序存储结构

​	1.顺序队列

​		**队头指针**（front）:指向**队头元素**

​		**队尾指针**（rear）:指向**队尾元素的下一个位置**

​		**初始状态（队空条件）**：**Q.front=Q.rear=0**

​		**进队操作**：判断**队满**，赋值，**rear++**

​		**出队操作**：判断**队空**，赋值，**front++**

​		当front 和rear都在结尾时，再次入队会出现溢出，这是**假溢出**，由此引出**循环队列**来**解决**这个问题。

​	2.**循环队列（重点）**

​		**初始状态**（**非**队空条件）：**Q.front=Q.rear=0**

​		**进队操作**：判断**队满**，赋值，Q.rear=(Q.rear+1)**%Maxsize**

​		**出队操作**：判断**队空**，赋值，Q.front=(Q.front+1)**%Maxsize**

​		**队列长度**：(Q.rear+**Maxsize**-Q.front)**%Maxsize**

​		判断队空，队满：

​				1.牺牲一个单元

​						**队满**条件：**(Q.rear+1)%Maxsize==Q.front**

​						**队空**条件：Q.front==Q.rear

​				2.增加表示元素个数的数据成员

​						队满条件：Q.front==Q.rear&&Q.size==Maxsize

​						队空条件：Q.front==Q.rear&&Q.size==0

​				3.类型中增加标志tag

​						队满条件:Q.front==Q.rear&&Q.tag==1

​							入队操作同时将tag置为1

​						队空条件:Q.front==Q.rear&&Q.tag==0

​							出队操作同时将tag置为0

#### 3.2.3 队列的链式存储结构

​	1.不带头节点的链式队列

​		队头指针：队头节点

​		队尾指针：队尾节点（**不同于顺序存储**）

​		初始状态：**Q.front=Q.rear=NULL**

​		入队操作：建立新节点s，rear->next=s，rear=rear->next(若为**第一个节点**，则**front=rear**)

​		出队操作：**判断队空**，取出队头元素,front=front->next(若**最后一个元素的删除**则置**front=rear=NULL**)

​		判断队空：Q.front**==**Q.rear**==NULL**（**仅等于无法判断**，只有一个元素也是等于）

​	2.带**头结点**的链式队列

​		**队头指针**：**头结点**

​		队尾指针：队尾节点

​		**初始状态**：**Q.front=Q.rear=head**

​		入队操作：建立新节点s，rear->next=s，rear=rear->next（**不用判断第一个节点**）

​		出队操作：**判断队空**，取出队头元素,front=front->next(若**最后一个元素的删除**则置**front=rear(非NULL**))

​		判断队空：Q.front**==**Q.rear(**不用判断NULL**,只有一个元素，front=head，rear不是)	

#### 3.2.4 双端队列

​	**输出受限**的双端队列：允许在**一端**进行**插入和删除**，另一端**只允许插入**

​	**输入受限**的双端队列：允许在**一端**进行**插入和删除**，另一端**只允许删除**

| **不能得到的** | 相同 | 不同 |
| -------------- | ---- | ---- |
| **输入受限**   | 4231 | 4213 |
| **输出受限**   | 4231 | 4132 |

​	**双端队列**的**可能序列**判断，在**中间画竖线**，**两边**方向**依次递增**。

​	列：b|acde,db|ace,ecb|ad	

### 3.3 栈的应用

#### 3.3.1.括号匹配

​			（1）遇到**左括号入栈**

​			（2）遇到**右括号出栈一个与它对比**，**不同则失败**

​			（3）**扫描完**时**栈为空**则**匹配**

#### 3.3.2**表达式求值**

| 转化           | 后缀表达式                                                   | 前缀表达式                                                   |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **中缀表达式** | 1.按优先级对所有运算单位加括号 <br />2.运算符移到括号**后面**<br />3.去括号 | 1.按优先级对所有运算单位加括号<br />2.运算符移到括号**前面**<br />3.去括号 |

​	注意不管哪种表达式，**变量的顺序不变**。

​	**后缀表示式**=**表达式树**的**后序遍历**

​			（1）**后缀表达式计算值**

​					依次扫描(**从左到右**)：

​							字母->入栈

​							符号->从栈中退出两个并计算，将计算结果入栈

​					栈顶为最后结果

​			（2）**前缀表达式计算值**

​					依次扫描(**从右到左**)：

​							字母->入栈

​							符号->从栈中退出两个并计算，将计算结果入栈(注意**计算次序**，基本原则是**字母顺序不变**)

​					栈顶为最后结果

​					练习：前缀表达式转中缀表达式：+-*^ABCD/E/F+GH

#### 3.3.3**栈在递归中的应用**

​			**递归**：在一个函数，过程或数据结构的定义中又应用了它本身。

​			**递归条件**：	**递归表达式**（递归体）

​						**边界条件**（递归出口）

​			递归的**精髓**在于能否将原始问题**转换**为**属性相同**但**规模较小**的问题。

​			**任何一个**递归算法**都可以**用**栈转换**，但是**不一定**要用**栈转换**。

### 3.4 队列的应用

#### 3.4.1 二叉树层次遍历（图广度遍历）

​	1.根结点入队

​		while(队列不空)

​				队列第一个结点出队

​				访问第一个节点（输出）

​				若有左孩子，左孩子入队

​				若有右孩子，右孩子入队

#### 3.4.2 计算机系统中的应用

​	1.解决主机与外部设备之间速度不匹配的问题

​			打印机，等外部设备

​	2.解决由多用户引起的资源竞争问题

​			CPU调度等

### 3.5 特殊矩阵的压缩存储

### 3.6 练习

1.手写一个最小栈

```c
int stack[maxsize];int top=-1;	//声明加初始化
stack[++top]=x;		//进栈
x=stack[top--];		//出栈
```

2.栈和队列具有相同的逻辑结构    都是受限制的线性表

3.用链式存储方式的队列进行删除操作时需要（）  可能头尾指针都要改

4.利用两个栈模拟一个队列

​	见王道

5.后缀表达式求值的实现

6.中缀表达式求值的实现

7.普通计算器的实现

8.汉诺塔问题的实现及移动次数。 $2^n-1$

9.循环队列的引入，目的是为了克服      假溢出时大量移动数据

10.用一个大小为1000的数组来实现循环队列，当前的front和rear的值分别为994和0,则到队满的条件，还需要入队的个数为：        

​		1000-1-(999-994+1)  注意牺牲一个单元用判队满

11. 312模式：设进栈序列为1,2,3....,n  ，出栈为P1,P2,....Pn.

    ​			证明：不存在Pj<Pk<Pi(i<j<k)   即123序列中不会出现312

    ​			写出该判断的算法

    主要的判断依据是：若Xi已经出栈，则Xi前面的尚未出栈的元素一定逆置有序的出栈

    ```c
    int judge_312(int A[],int n)
    {
        int flag=0;
        int max;
        int min;
        int i=0;
        if(n==2)
            return 1;
        for(i=0;i<n;i++)
        {
            if(A[i]>A[n])
            {
                flag=1;
            }
            if(flag==1&&A[i]<A[n])
                return 0;
        }
        return judge_312(A,n-1);
    }
    ```


12.有n个元素放在数组A中，输出这些元素的全排列（递归）。

13.试推导出总盘数为n的hanoi塔的移动次数。

14.有字符串次序为3*-y-a/y^2,利用栈，给出将次序改为3y-\*ay2^/-的操作步骤。（进栈为X,出栈为S）

15.用栈实现进制转换。

16.用两个队列模拟栈的操作。

17.用两个栈模拟队列的操作。

18.用递归算法求出数组中的最大值和最小值。

19.递归算法求两个正整数m和n的最大公因数。

## 4. 树与二叉树

### 4.1 树的基本概念

​	树的结点数：N>=0,N=0时为空树

​	树适用于表示有**层次结构**的数据。

​	**N个结点**的树有**N-1条边**:   $N=n_1+n_2+n_3+...+n_m=n_1 *1 +n_2 *2+n_3*3+....+n_m*m+1$

​	树中结点的**最大度数**称为树的**度**

​	度>0的点称为**分支节点**，**度=0**的点称为**叶子节点（终端节点）**

​	结点层次：**根节点为1**

​	树的**高度（深度**）是树中结点的**最大层数**

​	**有序树**：结点的子树**从左到右**是**有次序**的，反之为**无序树**

​	**两个结点**的**路径**是由**这两个结点之间所经过的结点序列**构成的

​	**路径长度**是路径上所经过的**边的个数**

​	**树的路径长度**	是**从根结点到每一结点路径长度**的**总和**(不同于边的数量)

​	树中的相关性质（度为m）：

​			**第i层**：**至多**$m^{i-1}$个结点

​	(**重点**)	**按序号从上到下，每层从左到右编号满m叉树：**

​			则：**第 i 层节点数**：$m^{(i-1)}$

​				结点 i 的**第 k 个孩子**编号为：$(i-1)*m+1+k$    (前i-1个节点都有了m个孩子，再加上自己)

​				结点 i 的**双亲编号**为: $\lfloor(i-2)/m \rfloor +1$

|    m叉树     |                   至少                    |              至多               |
| :----------: | :---------------------------------------: | :-----------------------------: |
| 高度h->结点n |             $n_{min}=h+(m-1)$             | $n_{max}=\frac {(m^h-1)} {m-1}$ |
| 结点n->高度h | $h_{min}=\lceil log_m[n(m-1)+1]   \rceil$ |        $h_{max}=n-(m-1)$        |

​	 注意：**结点数=边+1**
$$
N=n_1+n_2+n_3+...+n_m=n_1 *1 +n_2 2+n_33+....+n_m*m+1
$$

​	任何一个树中的**叶子节点**数量为：$n_0=1+\sum^{m}_{i=1} (i-1)n_i $

​	**n个结点**构造的**不同的树**的数量:$Catalan(n-1)$

### 4.2 二叉树的概念

#### 4.2.1 二叉树的定义及主要特性

​	二叉树的**度>=2**

​	二叉树**可以**是**空树**

​	二叉树是**有序树**

​	对比**度为2的有序树**：

​			度为2的有序树不可以为空，且**最小结点数为3**

​			**二叉树**的结点次序**不是相对另一结点而言**，是确定的

​	**满二叉树**：

​				$n=2^h-1$

​				$n=2n_0-1$

​				根为i:**左孩子为2i,右孩子为2i+1**

​	**完全二叉树：**

​				$n_1=1或0$

​				$n=2n_0-1$或者$n=2n_0$

​	

| 完全二叉树                          | 至少            | 至多             |
| ----------------------------------- | --------------- | ---------------- |
| 高度h->结点n                        | $2^{(h-1)}$     | $2^h-1$          |
| 第 i 层有 <br />k 个叶子结点->结点n | $2^{(i-1)}-1+k$ | $2^{(i+1)}-2k-1$ |

​	**二叉树性质**：

​				$n_0=n_2+1$

​				**第k层至多**$2^{k-1}$

​				**n个结点**构造的**不同的二叉树**的数量:$Catalan(n)$

|    二叉树    |                             至少                             |      至多       |
| :----------: | :----------------------------------------------------------: | :-------------: |
| 高度h->结点n |                         $n_{min}=h$                          | $n_{max}=2^h-1$ |
| 结点n->高度h | $h_{min}=\lceil log_2(n+1)  \rceil$<br />或$\lfloor log_2n \rfloor+1$ |   $h_{max}=n$   |

​	n个结点的二叉树有**n+1个空链域**

#### 4.2.2 二叉树的存储结构

​	**顺序存储结构**：将编号为i的节点元素存储到数组下标为i-1的分量中

​					完全二叉树和满二叉树适合用来存储。

​	**链式存储结构**：分为**数据域，左指针域和右指针域**。

### 4.3 二叉树的遍历和线索二叉树

#### 4.3.1 二叉树的遍历

​	遍历：**先序遍历**，**中序遍历，后序遍历**

​	三种遍历方式的**时间复杂度**都是**O(n)**,**空间复杂度**都是**O(n)**.

​	三种遍历方法中**叶子节点**的**遍历先后顺序**都是**固定**的。

​	可以用**后序遍历**找到**祖先的路径**

​	前序序列和中序序列的关系是以**前序序列**为**入栈次序**，**中序序列**为**出栈顺序**（卡特兰数）

| 形态       | 相同    | 相反             |
| ---------- | ------- | ---------------- |
| 先序，后序 | 只有根  | $N_0=1（N_2=0）$ |
| 先序，中序 | $N_L=0$ | $N_R=0$          |
| 中序，后序 | $N_R=0$ | $N_L=0$          |
| 先序，层次 | $N_2=0$ | 只有根或空树     |
| 中序，层次 | $N_L=0$ | $N_R=0$          |
| 后序，层次 | $N_2=0$ | $N_0=0$          |

ssr	**二叉树的非递归遍历（见习题）**。

​	**二叉树的层次遍历(同图的广度遍历)**，需要**借助队列**。

​	由**遍历序列构造二叉树**：（见习题）

​					1.**先序序列+中序序列**

​					2.**后序序列+中序序列**

​					3.**层次序列+中序序列**

​		**前序序列**和**后序序列不能唯一确定二叉树**，但是可以**确定节点的祖先关系**，**前序**序列为**XY**与**后序**序列为**YX**时（**两者相邻**！），**X为Y的祖先**。

#### 4.3.2 线索二叉树

​	1.**概念**

​	线索二叉树是个**物理结构**

​	实质就是对一个**非线性结构进行线性化操作**

​	每个线索二叉树都有**n+1**个线索（每个树都有n+1个空指针）

​	**线索化**后的**空的链域**为：

| 线索化后空链域数 |       1        |      2       |
| ---------------- | :------------: | :----------: |
| **先序**线索树   | 根左子树不为空 | 根左子树为空 |
| **中序**线索树   |     不存在     |      =       |
| **后序**线索树   | 根右子树不为空 | 根右子树为空 |

​	引入线索二叉树是**为了加快查找结点前驱**和**后继**的**速度**。

​	二叉树线索化时：若**无左子树（ltag=1**）,令**lchild指向前驱**节点。

​					若**无右子树（rtag=1**）,令**rchild指向前驱**节点。

​	带**头节点**的线索二叉树：

​			线索化后**空的链域为0**

​			头节点**左孩子**为**根节点**，**右孩子**为**最后访问的节点**

​			序列的**第一个节点**的**左孩子**和**最后一个节点**的**右孩子**指向**头节点**

​	中序线索树的前驱后继容易求出（左孩子最右边，右孩子最左边）。

​	**先序线索树**的**后继**容易求出，但是**前驱必须知道双亲**（栈存取），前序线索树的**遍历不需要栈**的支持。

​	**后序线索树**的**后继**不能求出，**必须知道双亲**（栈存取），后序线索树的**遍历**需要**栈**的支持(**一般**)。

​	注：**并非所有**后序线索树遍历**都要用栈**，比如**任何结点最多只有左子树**的后序线索树就不需要。



**不是每个节点**都可以**通过线索**找到它的**前驱和后继**，**先序线索树**的**前驱**必须**知道双亲**，**后序线索树**的**后继**必须知道**双亲**。

### 4.4 树，森林

#### 4.4.1 树的存储结构

​	1.**双亲表示法**

​		采用一组**连续空间**来存储每个结点（类数组），**伪指针域**为**-1（无双亲）**或者指向**双亲结点下标**。

​		可以**很快**得到每个结点的**双亲**结点，但是求**孩子**结点需要**遍历整个结构**。

​	2.**孩子表示法（手绘）**

​		将**每个结点**的**孩子结点**都用**单链表链接**起来。

​		找**子女**非常**直接**，寻找**双亲**需要**遍历N个节点中孩子链表指针域所指向的N个孩子链表**。

​	3.**孩子兄弟表示法（手绘）**

​		又称**二叉树表示法**

​		**二叉链表**作为存储结构         |指向**第一个孩子结点**的指针|**结点值**|**下一个兄弟结点**的指针

​		方便实现**树转二叉树**的操作，**易于查找孩子**。

​	注：**森林**中有**n个结点b条边**，则**森林**中共有**n-b棵树**。

#### 4.4.2 树，森林与二叉树的转换

​	**左孩子右兄弟**。

​	**森林F->二叉树B**：	

​					***B中无右孩子结点数=F中非叶节点数+1**

​					***F中叶结点数=B中无左孩子结点数**



#### 4.4.3 树和森林的遍历

​	**树的遍历**：

​			**先根遍历**：先访问**根结点**，再依次**先根遍历子树**。

​			**后根遍历**：顺序**后根遍历**子树，再访问**根节点**。

​	**森林的遍历**：

​			**先序遍历**：1.访问森林中第一棵树的根节点  

​					   2.先序遍历第一棵树中根节点的子树森林

​					   3.先序遍历除去第一棵树之后剩余的树构成的森林

​			***中序遍历**：1.中序遍历森林中第一棵树的根节点的子树森林

​					   2.访问第一棵树的根节点

​					   3.中序遍历除去第一棵树之后剩余的树构成的森林

| 树           | 森林         | 二叉树       |
| ------------ | ------------ | ------------ |
| **先根遍历** | **先序遍历** | **先序遍历** |
| **后根遍历** | **中序遍历** | **中序遍历** |

| 森林（树） F | 二叉树 B             |
| ------------ | -------------------- |
| $F_0$        | $B_R+B_0$            |
| $F-F_0$      | $B_L+B_0-1(B_L+B_2)$ |

​	其中 $B_1=B_L+B_R$,$B_L$代表只有左子树的节点个数，$B_R$代表只有右子树的节点个数。

#### 4.4.4 并查集

#### 4.4.5 哈夫曼树 哈夫曼编码

​	**WPL** 树的带权路径长度是指树中的所有的叶子节点的带权路径的长度之和

​	**哈夫曼树的特点**

​		权值越大的节点 离根节点越近

​		树中没有度为**1**的节点

​		树的带权路径最短 

​	**哈夫曼编码**

​		任一字符的编码串都不是另一字符编码的前缀串的前缀

​		根通往任一叶子节点的路径都不可能是通往其余叶子节点路径的子路径

​	**哈夫曼N叉树**

​		构造方法同二叉树类似

​		度为m的哈夫曼树中，叶子节点个数为n，则非叶子节点的个数为 (n-1)/(m-1)

### 5. 练习

#### 5.1 二叉树

1.已知一棵二叉树按顺序存储结构进行存储，设计一个算法，求编号分别为 i 和 j 的两个结点的最近的公共祖先结点的值。

```c
while(i!=j)
       (i>j?i:j)/=2;
	return T[i];
```

2.**先序遍历**的**非递归**算法。（同时请参考1800 算法41）

​	借助栈，根节点先入栈，之后栈不空循环，访问出栈节点后入右左节点。

```c
void PreOrder(Bitree T)
{
    InitStack(S);Bitree p=T;	//借助栈
    Push(S,p);			//根节点入栈
    while(!IsEmpty(S))		//栈空时则退出循环    
    {
        Pop(S,p);visit(p);	//出栈并访问
        if(p->rchild)		//若有右孩子，则右孩子进栈
            Push(S,p->rchild);
        if(p->lchild)		//若有左孩子，则左孩子进栈
            Push(S,p->lchild);
    }
}
```

3.**中序遍历**的**非递归**算法。（同时情参考1800算法31）

​	中序遍历第一个总是最左端的，然后右边走一次再次走到最左端

```c
void InOrder(Bitree T)
{
    InitStack(S);Bitree p=T;	//借助栈
    while(p||!IsEmpty(S))		//栈不空或者p不空的时候循环
    {
        if(p)			//走到最左端
        {
            Push(S,p);
            p=p->lchild;
        }
        else{			//若为空则出栈（中间节点）并访问，再走右边孩子
            Pop(S,p);visit(p);
            p=p->rchild;
        }
    }
}
```

4.**后序遍历**的**非递归**算法。（同时请参考1800算法42）

```c
void PostOrder(Bitree T)
{
    InitStack(S);Bitree p=T;	//借助栈
    Bitree r=NULL;		//辅助指针指向最近访问的结点
    while(p||!IsEmpty(S))		//栈不空或者p不空的时候循环
    {
        if(p)
        {
            Push(S,p);
            p=p->lchild;
        }
        else{
            Gettop(S,p);	//注意不是pop
            if(p->rchild&&p->rchild!=r)
            {
                p=p->rchild;
                push(S,p);
                p=p->lchild;
            }
            else
        }
    }
}
```

5.**层次遍历**的**非递归**算法。

```c
void LevelOrder(BiTree T)	//二叉树的层次遍历算法
{
    InitQueue(Q);
    BiTree p;
    EnQueue(Q,T);	//根节点入队
    while(!IsEmpty(Q))	//队列不空则循环
    {
        DeQueue(Q,p);	//出队列
        visit(p);	//访问节点
        if(p->lchild)	//有左孩子则入队
            EnQueue(p->lchild);
        if(p->rchild)	//有右孩子则入队
            EnQueue(p->rchild);
    }
}
```

6.给出某二叉树**先序遍历**数组A[1...n]和**中序遍历**数组B[1...n]，编写算法建立该二叉树的二叉链表。

​	（1）根据先序序列确定树的根节点

​	（2）根据根节点在中序序列中划分出的二叉树的左右子树所包含的结点，然后根据左右子树的结点在先序序列中的次序可以确定子树的根结点，即回到步骤（1）

​	重复直到每个子树仅有一个节点为止。

```c
Bitree PreInCreat(ElemType pre[],ElemType in[],int L1,int H1,int L2,int H2)
{	//l1和h1为先序的第一和最后一个结点下标，l2,h2为中序的第一和最后一个结点下标
    //初始时，l1=l2=1,h1=h2=n
    int L_len,R_len;
    Bitree root=(BiTNode*)malloc(sizeof(BiTNode));		//建根节点
    root->data=pre[L1];								//根节点的数据
    for(i=L2;in[i]!=root->data;i++);					//查找根所在位置
    L_len=i-L2;					//左子树的长度（结点个数）
    R_len=H2-i;					//右子树的长度（结点个数）
    if(L_len)				//递归建立左子树
    	root->lchild=PreInCreat(pre,in,L1+1,L1+L_len,L2,L2+L_len-1);
    else					//左子树为空
        root->lchild=NULL;
    if(R_len)				//递归建立右子树
    	root->rchild=PreInCreat(pre,in,H1-R_len+1,H1,H2-R_len+1,H2);
    else					//右子树为空
        root->rchild=NULL;
    return root;			//返回根结点   
}
```

```c
Bitree PreInCreat(ElemType *pre,ElemType *in,int A_len)
{	//A_len 是当前树的长度
    int n=A_len;
    Bitree *p; int k;
    if(n<=0) return NULL;
    Bitree root=(BiTNode*)malloc(sizeof(BiTNode));
    root->data=*pre;
    for(p=in;p<in+n;p++)
        if(*p==*pre) break;		//找到根节点
    k=p-in;			//获得左子树的长度
    root->lchild=PreInCreat(pre+1,in,k);	//建立左子树
    root->rchild=PreInCreat(pre+1+k,in+1+k,n-1-k);		//建立右子树
}
```

7.给出某二叉树**后序遍历**数组A[1...n]和**中序遍历**数组B[1...n]，编写算法建立该二叉树的二叉链表。

```c
Bitree PostInCreat(ElemType post[],ElemType in[],int L1,int H1,int L2,int H2)
{	
}
```



8.给出某二叉树**层次遍历**数组A[1...n]和**中序遍历**数组B[1...n]，编写算法建立该二叉树的二叉链表。

```c
//此代码出自CSDN 非递归的 但是有点长-- 大佬有更好的算法的话 给改进下吧
BiTree levInCreat(ElemType lev[],ElemType in[],int n)
{
    BiTree helper[n],result;                                              
    int i,p;
    for(i = 1;i <= n;i++)                              //初始化helper数组
        helper[i] = 0;                      
    bool success;
    result = (BiTree)malloc(sizeof(BTNode));
    result->data = lev[1];
    int mi;
    for(mi=1;mi<=n;mi++)             //寻找层次遍历中第一个元素(也就是根节点）    
        if(in[mi]==lev[1])
            break;
    helper[mi] = result;             //根据中序遍历序列中mi（也就是根节点）的位置
                                     //在helper中也在相同的位置储存result
    for(i=2;i<=n;i++) 
    {
        success = false;
        for(mi=1;mi<=n;mi++)
        if(in[mi]==lev[i])
            break;
        helper[mi] = (BiTree)malloc(sizeof(BTNode));
        helper[mi]->data = lev[i];
        
        for(p = mi-1;p>=1;p--)   //在当前节点m1的左边开始寻找 如果找到了一个非0节点p 
        {                        //如果p的右子树为空 helper[mi]就是p的右子树
            if(helper[p]!=0)
            {
                if(helper[p]->rchild==0)
                {
                    helper[p]->rchild = helper[mi];
                    success = true;
                }
                break;
            }
        }
        
        if(success) continue;     //如果已经找到非零节点 则无需进行下一次循环
        
        for(p = mi+1;p >= n;p++)//在当前节点m1的右边开始寻找 如果找到了一个非0节点p           
        {                       //如果p的左子树为空 helper[mi]就是p的左子树
            if(helper[p]!=0)
            {
                if(helper[p]->lchild = 0)
                {
                    helper[p]->lchild = helper[mi];
                }
                break;
            }
        }
    }
    return result;
}
```



1800上算法题51

15.给出二叉树的自下而上，从右到左的层次遍历算法

​	解：使用层次遍历，每次出队列时将该节点放入一个栈中，当层次遍历结束时，将所有的栈中数据退栈。

16.非递归算法求二叉链表表示法的二叉树高度。

​	解：使用层次遍历的算法，last指向当前层最右边的结点，每次出队都与last比较，若两者相等，则层数加1，并让last指向下一层的最右结点。（注，本代码不使用队列的标准操作）

```c
int Btdepth(BiTree T)
{
    if(!T)
        return 0;	//判空
    int front=-1,rear=-1; 
    BiTree Q[Maxsize];//队列初始化,注意队列尾指针指向队尾元素
    int last=0,level=0;
    Q[++rear]=T;	//根节点入队
    BiTree p;
    while(front<rear)	//队不空则循环
    {
        p=Q[++front];	//队列元素出队，即正在访问的结点
        if(p->lchild)	//左孩子不空，则入队
            Q[++rear]=p->lchild;
        if(p->rchild)	//右孩子不空，则入队
            Q[++rear]=p->rchild;
        if(front==last)	//代表出队列的结点为最右元素
        {
            level++;	//层数++
            last=rear;	//将last指向下一层中最右元素
        }
    }
}
```

17.对于树中每一个元素值为x的结点，删去以它为根的子树，并释放相应的空间。

​	解：需要删除该节点的父结点指向其的指针，同时递归的删除该节点为根的树

​		使用层次遍历算法来找到父结点

```c
void DeleteXTree(BiTree bt)	//递归的删除bt为根的树
{
    if(bt)
    {
        DeleteXTree(bt->lchild);
        DeleteXTree(bt->rchild);
        free(bt);
    }
}
void SearchAndDeleteX(BiTree bt,ElemType x)	//删除树中所有节点值为x的结点
{
    InitQueue(Q);	//借助队列
    if(bt)
    {
     	if(bt->data==x)	//根为x则全部删除
            DeleteXTree(bt);
        exit(0);
        EnQueue(bt);	//根节点入队
        while(!IsEmpty(Q))	//队不空则循环
        {
            DeQueue(Q,p);	//出队
            if(p->lchild)	//左孩子非空
            {
                if(p->lchild->data==x)	//左孩子为x
                {
                    DeleteXTree(p->lchild);	//递归删除左孩子
                    p->lchild=NULL;	//左孩子指针置空
                }
                else
                    EnQueue(Q,p->lchild);	//否则左孩子入队
            }
            //右孩子操作相同
            if(p->rchild)	//右孩子非空
            {
                if(p->rchild->data==x)	//右孩子为x
                {
                    DeleteXTree(p->rchild);	//递归删除右孩子
                    p->rchild=NULL;	//右孩子指针置空
                }
                else
                    EnQueue(Q,p->rchild);	//否则右孩子入队
            }
        }
    }
}
```



18.在二叉树中查找值为x的结点，试编写算法打印值为x的节点的所有祖先，假设值为x的结点不多于一个。

​	解：使用非递归的后序遍历，具体参照王道p123   12

20.求非空二叉树的宽度（结点最多的一层的结点个数）

21.满二叉树，知道其先序序列，求其后序序列

22.将二叉树的叶结点按从左到右的顺序连成一个单链表。

23.判断两个二叉树是否相似

```c
bool similar(BiTree T1,BiTree T2)
{
    int LEFT,RIGHT;
    if(T1==NULL&&T2==NULL)
        return 1;
    else if(T1==NULL||T2==NULL)
        return 0;
    else
    {
        LEFT = similar(T1->lchild,T2->lchild);
        RIGHT= similar(T1->rchild,T2->rchild);
        return LEFT&&RIGHT;
    }
}
```



23.1判断两个二叉树是否相等（1800 63）

24.求出二叉树的带权路径长度（WPL）

```c
static int wpl = 0; //全局变量来保存wpl
int Pre_Order(BiTree root,int deep)
{
    if(root->lchild==NULL && root->rchild==NULL)         //为叶节点的时候则累加
    	wpl+=deep*root->weight;
    if(root->lchild!=NULL)                               //左子树不空 则对左子树递归
        Pre_Order(root->lchild,deep+1);
    if(root->rchild!=NULL)
        Pre_Order(root->rchild,deep+1);                  //右子树不空 则对右子树递归
    return wpl;
}

int wpl(BiTree root)
{
    Pre_Order(root,0);
    return wpl;
}
```



25.设计一个算法，将给定的表达式树转换为等价的中缀表达式并输出。

26.求一棵二叉树的p,q的公共节点

​	二叉链表的实现方式：

```c
#defined maxsize 1000
typedef struct SNode         
{
	BiTree t;
    int tag;
}SNode;

BiTree findCommonNode(BiTree t,BiTree p,BiTree q)
{
    SNode s[maxsize],s1[maxsize];
    int top,top1,i,j;
    top=top1=0;
    BiTree bt;
    bt = t;
    while(bt||top>0)
    {
        while(bt!=null && bt!=p && bt!=q)
        {
            s[++top].t=bt;
            s[++top].tag=0;
            bt = bt->lchild;
        }
        if(bt==p)
        {
            for(i=1;i<=top;i++)
                s1[i]=s[i];
            top1 = top;
        }
        if(bt==q)
        {
            for(i=top;i>0;i--)
                for(j=top1;j>0;j--)
                    if(s1[j].t==s[i].t)
                    {
                        return s[i].t;
                    }
        }
        while(top!=0 && s[top].tag==1) top--;
        if(top!=0)
        {
            s[top].tag=1;
            bt=s[top].t->rchild;
        }
    }
    return NULL;
}
```



​	顺序表的实现方式:

```c
ElemType findCommonNode(SqTree T,int i,int j)
{
        while(i!=j)
        {
            if(i>j)
                i = i/2;
            else
                j = j/2;
        }
        return T[i];
}
```

27.已知一棵树的层次序列以及每个节点的度，编写算法构造树的孩子-兄弟链表。

```c
#define maxsize 15
void createCSTree_Degree(CSTree &T,DataType e[],int degree[],int n)
{
    CSNode *pointer[maxsize];
    int i,j,d,k=0;
    for(i=0;i<n;i++)
    {
        pointer[i] = (CSTree)malloc(sizeof(CSNode));
        pointer[i]->data = e[i];
        pointer[i]->lchild = pointer[i]->rsilbling = NULL;
    }
    for(i=0;i<n;i++)
    {
        d = degree[i];
        if(d)
        {
            k++;
            pointer[i]->lchild = pointer[k];
            for(j=2;j<=d;j++)
            	pointer[k]->lchild = pointer[k++];
        }
    }
    T = pointer[0];
    free(pointer);
}
```



到王道p124



1800



1.使用**递归**算法完成以下**二叉树**操作：

​				（1）高度

​				（2）总结点个数

​				（3）交换左右子树

​				（4）叶子节点个数

​				（5）度为2的结点个数

​				（6）度为1的结点个数(同上类似)

​	解：（1）

```c
int height(B)
{	int hl,hr;
    if(!B)
        return 0;
 	hl=height(B->lchild);
 	hr=height(B->rchild);
 	return hl>hr?hl+1:hr+1;
}
```

​	解：（2）

```c
int size(B)
{
        return (!B)?0:(size(B->lchild)+size(B->rchild)+1);
}
```

​	解：（3）使用**后序遍历**的思想，为空时递归终点倒回

```c
void exchange(B)
{	
    if(B)	//判空（必写，出口）
    {
        exchange(B->lchild);	//先递归交换左子树
        exchange(B->rchild);	//递归交换右子树
        t=B->lchild;			//交换根
        B->lchild=B->rchild;
        B->rchild=t;
        
    }
}
```

 	解：（4）采用递归算法 叶子节点个数=左子树的叶子节点个数+右子树的叶子节点个数，出口为叶子节点

```c
int num_leaf(B)
{
    if(!B->lchild)
        if(!B->rchild)
            return 1;
    return num_leaf(B->lchild)+num_leaf(B->rchild);
}
```

​	解：（5）

```c
int TwoNodes(B)
{
    if(!B)
        return 0;
    else if(B->lchild&&B->rchild)
        return TwoNodes(B->lchild)+TwoNodes(B->rchild)+1;
    else
        return TwoNodes(B->lchild)+TwoNodes(B->rchild);
}
```

2.使用**非递归**算法**交换**二叉树的**左右子树**

​	使用类似层次遍历的方式，交换每个结点的左右子树

(1)使用队列的方式

```c
void exchange(B)
{
    BiNode *p,*q;
    if(B)
    {
        EnQueue(Q,B);			//根结点入队
        while(!QueueEmpty(Q))	//队为空则退出
        {
            DeQueue(Q,q);		//出队一个
            if(p->lchild)  EnQueue(Q,p->lchild);	//若有左子树，则入队
            if(p->rchild)  EnQueue(Q,p->rchild);	//若有右子树，则入队
            q=p->rchild;			//交换左右子结点
            p=q->lchild;
            p->lchild=q;
        }
    }
    
}
```

（2）使用栈的方式

```c
类似队列方式，
			（1）根节点放入栈
			（2）当栈不空时，取出栈顶元素，交换它的左右子树，并把它的左右子树分别入栈
			（3）重复（2）直到队列为空
```

5.**判别**给定的二叉树是否是**完全二叉树**的算法。

​	解：使用层次遍历的方式，借助队列，利用完全二叉树“若某结点无左子树就不该有右子树”的原则判断。

具体的操作为设置标志位，用层次遍历的方式，若层次遍历中已经出现结点孩子指针为空的结点，再次出现时则不为完全二叉树。

```c
int judge_complete_BT(B)
{
    BiNode *p=B;
    int tag=0；		//用来标注前面的结点为空的个数
    if(p==NULL) return 0;
    EnQueue(Q,p);	//根结点入队
    while(!QueueEmpty(Q))	//队为空则退出
 	{
        DeQueue(Q,q);		//出队一个
        if(p->lchild&&!tag)		//若前面没有非空的结点并且左孩子存在
           EnQueue(Q,p->lchild);		//左孩子入队
        else if(p->lchild)		//若前面已经有空结点
           return 0;			//返回0
        else
            tag=1;		
        //右孩子相同操作
         if(p->rchild&&!tag)	
           EnQueue(Q,p->rchild);		
        else if(p->rchild)		
           return 0;			
        else
            tag=1;		
     }
    return 1;
    
}
```



6.一颗**完全二叉树**

​			（1）由**顺序存储结构**转换为**链式存储结构**

​			（2）由**链式存储结构**转换为**顺序存储结构**

​	解（1）

```c
BiTree Creat(ElemType A[],int i,int n)	//n为数组的长度,i为结点位置，初始为1
{
    BiTree tree;
    if(i<=n)
    {
        tree=new(BiNode);
        tree->data=A[i];
        //建立左子树
        if(2*i>n)	//若左子节点为空
            tree->lchild=NULL;
        else		//不为空则递归的建立左子树
            tree->lchild=Creat(A,2*i,n);
        
        //建立右子树
        if(2*i+1>n)	//若右子节点为空
            tree->rchild=NULL;
        else		//不为空则递归的建立右子树
            tree->rchild=Creat(A,2*i+1,n);   
    }
    return tree;
}
```

​	解：（2）采用递归方式

```c
void Creat(int A[],int i,BiTree B)	//A存放转换后的顺序存储结构，i为指定的位置，初始为1
{
    if(B)
    {
        A[i]=B->data;
        //如果左孩子结点存在，则递归的建立左孩子
        if(B->lchild)
            Creat(A,2*i,B->lchild);
        //如果右孩子结点存在，则递归的建立右孩子
        if(B->rchild)
            Creat(A,2*i+1,B->rchild);
    }
}
```

​		同时可采用非递归方式,使用层次遍历的方式

```c
void Creat(bt,A)
    //使用两个队列，队列Q1用来存放节点，队列Q2用来存放下标
{	
    EnQueue(Q1,bt);
    EnQueue(Q2,1);
    while(!QueueEmpty(Q1)&&!QueueEmpty(Q2))
    {
        p=DeQueue(Q1);
        i=DeQueue(Q2);
        A[i]=p->data;
        //如果存在左孩子，则将左孩子的结点和左孩子的下标存入队列中
        if(p->lchild)
        {
            EnQueue(Q1,p->lchild);
            EnQueue(Q2,i*2);
        }
        //如果存在右孩子，则将右孩子的结点和右孩子的下标存入队列中
        if(p->rchild)
        {
            EnQueue(Q1,p->rchild);
            EnQueue(Q2,i*2+1);
        }
        
    }
}
```



9.求结点的双亲，求结点的孩子结点，求二叉树的深度，求二叉树的叶子结点个数，判断两棵二叉树是否相同。

10.二叉树的两个结点的共同祖先，单个节点祖先，最长叶节点路径等需要祖先的问题均可使用后序遍历的非递归算法来实现，详见(1800 算法16,22)

11.求二叉树的先序序列遍历的最后一个结点的指针，使用非递归方式，且不用栈

​	解：从根开始的任何结点，若有右子树，则是右子树最右下的结点，否则为左子树最右下的结点。

```c
BiNode* PreOrder_Last(BiTree B)
{	
    BiNode *p=B;
    while(p)
    {//依次序来，有右孩子就向右，没有就向左，为叶子结点则返回
        if(p->rchild)
            p=p->rchild;
        else if(p->lchild)
            p=p->lchild;
        else
            return p;
	}
}
```

12.求二叉树的后序遍历的第一个结点的指针。使用非递归方式，且不用栈

​	解：若有左子树，则为左子树最左下的叶结点，若无左子树，则为右子树上最左下的叶子节点

```c
BiNode* PostOrder_First(BiTree B)
{	
    BiNode *p=B;
    while(p)
    {//依次序来，有左孩子就向左，没有就向右，为叶子结点则返回
        if(p->lchild)
            p=p->lchild;
        else if(p->rchild)
            p=p->rchild;
        else
            return p;
	}
}
```

12.给出二叉树的自下而上，自右而左的层次遍历算法。

​	解：普通的层次遍历算法，每次出队列时进栈即可，最后一次出栈。

13.满二叉树：

​		（1）给出一个把后序遍历序列转化为先序遍历序列的算法。

​		（2）给出一个把先序遍历序列转化为后序遍历序列的算法。

​	解：（1）主要思想是满二叉树的左子树的数量和右子树的数量相同，先序序列的根为其第一个数。

```c
void PostToPre(ElemType post[],pre[],int L1,int H1,int L2,int H2)
//其中L1,H1为post的头尾下标，同理L2,H2为pre的头尾下标
{
    int num=0;	//记录左或者右子树的结点个数
    if(H1>=L1)		//在头尾下标正常时递归
    {
        pre[L2]=post[H1];//后序遍历的根节点为最后一个
        num=(H1-L1)/2;	//左右子树的节点数相同
        PostToPre(post,pre,L1,L1+num-1,L2+1,L2+num);	//递归建立左子树
        PostToPre(post,pre,L1+num,H1-1,L2+num+1,H2);	//递归建立右子树
    }
}
```

​	解：（2）与上面类似

14.所有分支节点度数为2的二叉树称为正则树，写一个算法判断一颗树是否是正则树。（递归）

​	解：采用任何递归遍历算法，将访问节点的操作改为判断度是否为1，为1则非二叉树。



15.前中后序非递归遍历的顺序结构存储方式。

16.前中后序递归遍历的顺序结构存储方式。

17.复制一个二叉树的算法

​		（1）递归算法

​		（2）非递归算法

```c
BiTree Copy(BiTree B)
{	
	BiTree T;
    if(B==NULL) T=NULL;
    else{
        T=new(BiNode);
        T->data=B->data;
        T->lchild=Copy(B->lchild);
        T->rchild=Copy(B->rchild);
    }
    return T;
}
```

```c
BiTree Copy(BiTree B)	//使用两个队列
{
    BiTree T;
    BiNode *p=B;
    //两个头节点入队列
    EnQueue(Q1,p);
    EnQueue(Q2,T);
    while(!QueueEmpty(Q1)&&!QueueEmpty(Q2))
    {	
        //出队列
        p=DeQueue(Q1);
        T=DeQueue(Q2);
        T=new(BiNode);
        T->data=p->data;
        //复制左孩子
        if(p->lchild)
        {
            EnQueue(Q1,p->lchild);
            EnQueue(Q2,T->lchild);
        }
        else
            T->lchild=NULL;
        //复制右孩子
        if(p->rchild)
        {
            EnQueue(Q1,p->rchild);
            EnQueue(Q2,T->rchild);
        }
        else
            T->rchild=NULL;     
    }
}
```

18.利用叶子节点中的空指针域将所有叶子节点链接为一个带头结点的双链表。（1800算法57）

19.二叉链表指定某一层k上的叶子节点的个数。（1800算法71）

​	解：采用层次遍历的方式

20.



#### 5.2树

1.以孩子兄弟链表为存储结构，请设计递归和非递归的算法求树的深度。（1800,算法15）

2.编写递归程序求以孩子兄弟链表结构表示的树的叶子节点个数。(1800 算法68)

3.编写程序计算以孩子兄弟链表表示的树T的度。（1800算法73）

4.

#### 5.3线索树

1。线索树的插入问题（1800 算法75,76,77）

9.构造**前序**线索二叉树

10.构造**中序**线索二叉树

11.构造**后序**线索二叉树

12.前序线索二叉树的遍历

​	

13.中序线索二叉树的遍历

​	不带头结点

```c
ThreadNode *Firstnode(ThreadNode *p)	//中序线索二叉树中中序序列下的第一个结点
{
    while(p->ltag==0)
        p=p->lchild;	//最左下结点
    return p;
}
ThreadNode *Nextnode(ThreadNode *p)		//后继结点
{
    if(p->rtag==0)		//无线索，则遍历右子树
        return Firstnode(p->rchild);
    else				//有线索，则返回线索
        return p->rchild;
}
void Inorder(ThreadNode *T)		//遍历中序线索二叉树
{
    for(ThreadNode *p=Firstnode(T);p!=NULL;p=Nextnode(p))
        visit(p);
}
```

```c
void Inorder(ThreadNode *T)
{
    ThreadNode *p=T;	//指向正式序列的第一个值
    while(p)		//若最后指向NULL则退出
    {
        while(p->ltag==0)	//访问中序下第一个结点
        	p=p->lchild;
        visit(p);
        while(p->rtag==1)	//有线索则访问下一个，注意最后一个右孩子为NULL
        {
            p=p->rchild;
            visit(p);
        }
        p=p->rchild;		//走到无线索，向右走
    }
}	
```

带头结点

```c
void Inorder(ThreadNode *T)
{
    ThreadNode *p=T->lchild;	//指向正式序列的第一个值
    while(p!=T)		//若最后指向头结点则退出
    {
        while(p->ltag==0)	//访问中序下第一个结点
        	p=p->lchild;
        visit(p);
        while(p->rtag==1&&p->rchild!=T)	//有线索则访问下一个，注意最后一个线索指向头结点
        {
            p=p->rchild;
            visit(p);
        }
        p=p->rchild;		//走到无线索，向右走
    }
}
```

14.后序线索二叉树的遍历

15.写出在

​		中序线索二叉树里查找指定结点在后序的前驱结点的算法。

```c
BiTree findNode(BiTree T,BiTree bt)
{
    if(bt->rtag==0)                          //存在右子树时
        return bt->rchild;
    else if(bt->ltag==0)                     //不存在右子树 但有左子树
        return bt->lchild;
    else if(bt->lchild==NULL)                //为中序第一节点 所以无后序前驱结点
        return NULL;
    else                                     //其他情况
    {
        while(bt->ltag&&bt->lchild!=NULL)
            bt = bt->lchild;
        if(bt->ltag==0)
            return bt->lchild;
        else                                  //此种情况为单枝树,bt为叶子,所以无后序前驱结点
            return NULL;                   
    }
}
```

​		中序线索二叉树里查找指定结点在前序下的后继结点的算法

```c
BiTree treNext(BiTree t)
{
    BiTree p;
    if(!t->ltag)
        p = t->lchild;
    else if(!t->rtag)
        p = t->rchild;
    else
    {
        p = t;
        while(p&&p->rtag)
            p = p->rchild;
        if(p)
            p = p->rchild;
    }
    return p;
}
```

​	

​	中序线索二叉树里中序下的最后一个节点

```c
BiTree inLast(BiTree t)
{
    BiTree p = t;
    while(p && !p->rtag)
    	p = p->rchild;
    return p;
}
```

​       中序下的前驱

```c
BiTree inPrior(BiTree t)
{
    BiTree p=t->lchild;
    while(p&&!p->rtag)
        p = p->rtag;
    return p;
}
```



附 

前序线索二叉树的前驱后继

中序线索二叉树的前驱后继

后序线索二叉树的给定结点的前驱后继，给定结点node,前驱或者后继储存到x

```c
void Post_prior(ThreadNode *node,ThreadNode *x)		//后序线索树前继结点
{
    if(node)	//判断空
        if(node->rflag==0)	//如果有右孩子，则右孩子一定为前驱
            x=node->rchild;
        else
            x=node->left;	//左孩子若存在，则没右孩子的情况下返回左孩子，左孩子若不存在则返回前驱线索
}
void Post_next(ThreadNode *bt,ThreadNode *node,ThreadNode *x)		//bt为根，后序线索树后继结点
{
    x=bt;	//赋值x为根
    if(node!=bt&&node!=NULL)
    {
        if(node->rflag)			//若有后序线索，则得到后序线索
            x=node->rchild;
        else{					
            //没有后序线索的情况下
            do{
                t=x;	//从根节点（后序序列最后一个结点）
                Post_prior(t,x);	//逐渐找前驱
            }while(x!=node);	//若该节点的前驱为node
            x=t;		//该节点为后继
        }
    }
}
```

王道p123


数据结构    

## 1.绪论

### 1.1基本概念	

​	数据结构的**基本单位**是**数据元素**。

​	数据结构的**最小单位**是**数据项**。

​	**数据对象**：具有相同性质的数据元素的集合。

​	**抽象数据类型（ADT）**：一个数学模型以及定义在该模型上的一组操作。（包括：**数据对象，数据关系，基本操作**），可以用来定义一个完整的数据结构。

​	**数据结构**：相互之间存在一种或多种特定**关系**的**数据元素**的**集合**（**数据对象，数据关系**）。

​	**数据结构三要素**：

​		1.**逻辑结构**：

​			（1）线性结构：

​					一般线性表，受限线性表（栈，队列，串），数组，广义表

​			（2）非线性结构；

​					集合，树形结构，图状结构

​		2.**存储结构**

​			（1）顺序存储

​			（2）链式存储

​			（3）索引存储

​			（4）散列存储

​		3.**数据的运算**

​			运算的定义：针对逻辑结构

​			运算的实现：针对存储结构

### 1.2 算法

#### 	1.2.1 算法的基本概念

​		算法是对特定问题求解步骤的一种描述。

​		算法的**特点**：**（1）有穷性（2）确定性（3）可行性（4）输入>=0（5）输出>0**

​		算法'好'的目标：（1）正确性（2）可读性（3）健壮性（4）效率与低存储量

#### 	1.2.2 算法效率的度量

​		**时间复杂度**：**算法问题规模n的函数**，与**执行时间**成**正比**。

​				不仅依赖于**问题的规模n**，也取决于待**输入数据的性质**

​				求法：**公式递推**或者**求和**。

​		**空间复杂度**：

​				算法**原地工作**：辅助空间是**常量**。

**时间复杂度的计算方法**：

​		**主方法：**
$$
T(n)=aT(n/b)+f(n)
\\(1)T(n)=O(n^{\log _b a}) \qquad if(f(n)阶数<\log _b a)
\\(2)T(n)=O(n^{\log _b a }\log _2 n) \qquad if(f(n)阶数=\log _b a)
\\(3)T(n)=O(f(n)) \qquad if(f(n)阶数> \log _b a)
$$

<div STYLE="page-break-after:always;"></div>

## 2.线性表

### 2.1 线性表的定义

​	 线性表（**逻辑结构**）具有**相同数据类型**的n个**数据元素**的**有限**序列。

​	线性表有两个**存储结构**：**顺序表，链表**。

### 2.2 顺序表

#### 	2.2.1 顺序表定义

​			表中元素的逻辑结构与物理结构**相同**。

​			最主要的特点是**随机访问**。 

#### 	2.2.2 顺序表基本操作

​			（1）插入**（$1\le i\le n+1$）**

​				每次移动：**n-i+1**个元素

​				平均次数：$\sum ^{n+1} _{i=1} \frac {1}{n+1} (n-i+1)=\frac {n}{2}$

​			（2）删除**（$1\le i\le n$）**

​				每次移动：**n-i**个元素

​				平均次数：$\sum ^{n} _{i=1} \frac {1}{n} (n-i)=\frac {n-1}{2}$

​			（3）**按值**查找（**顺序查找**）

​				每次查找：i

​				平均次数：$\sum ^{n} _{i=1} \frac {1}{n} *i=\frac {n+1}{2}$

​				时间复杂度：O(n)

​			（4）查找（有下标，普通）

​				1（随机存取）

### 2.3 链表

​	不要求逻辑上相邻的两个元素在物理上也相邻。

#### 	2.3.1 定义

​		头结点的作用是为了**方便运算的实现**。

#### 	2.3.2 基本操作

​		头插法，尾插法

### 2.4 总结

| T(n)                 | 删除最后 | 删除最前 | 最后插入 | 最前插入 |
| -------------------- | -------- | -------- | -------- | -------- |
| 单链表               | O(n)     | O(1)     | O(n)     | O(1)     |
| 循环单链表（头指针） | O(n)     | O(n)     | O(n)     | O(n)     |
| 循环单链表（尾指针） | O(n)     | O(1)     | O(1)     | O(1)     |
| 双链表（头指针）     | O(n)     | O(1)     | O(n)     | O(1)     |
| 双链表（尾指针）     | O(1)     | O(n)     | O(1)     | O(n)     |
| 双链表（头尾指针）   | O(1)     | O(1)     | O(1)     | O(1)     |
| 循环双链表           | O(1)     | O(1)     | O(1)     | O(1)     |

| T(n)             | 顺序表       | 链表     |
| :--------------- | ------------ | -------- |
| 插入             | O(n)         | O(1)     |
| 删除             | O(n)         | O(1)     |
| 按值查找（有序） | O($\log n$)  | O(n)     |
| 按值查找（无序） | O(n)         | O(n)     |
| 随机查找         | O(1)         | O(n)     |
| 排序             | O($n\log n$) | O($n^2$) |

注：若未知链表的结点位置，则需先查找后再插入（删除）。

​	1.链表的每个结点都恰好有一个指针。	错     双链表有两个

​	2.顺序存储结构属于静态结构，链式存储结构属于动态结构。   错    顺序存储也可动态分配

​	3.判断带头结点的单循环链表L仅有一个元素结点的条件是    L->next->next=L&&L->next!=L

​	4.判断。。。双循环。。。。。  L->next->next=L&&L->prior->prior=L&&L->next!=L

​	5.带头结点的双循环链表为空的条件是 L->next=L&&L->prior=L

<div STYLE="page-break-after:always;"></div>

## 3.栈和队列

### 3.1 栈

#### 3.1.1 栈的基本概念

​	逻辑结构：**线性表**（**操作受限**）

​	存储结构：1.顺序栈 2.链栈

​	数据运算：**先进后出**(**LIFO**)

#### 3.1.2 栈的顺序存储结构

​	1.顺序存储结构代码描述：

```c
#define Maxsize 50
typedef struct{
    Elemtype data[Maxsize];
    int top;
}SqStack;
```

​	栈顶指针：S.top，**初始时**设置**S.top=-1**；栈顶元素：S.data[S.top];

​	进栈操作：1.**判断栈满(S.top==MaxSize-1)** 2.**top++** 3.  S.data[S.top]=x

​	出栈操作：1.**判断栈空(S.top==-1)** 2.x=S.data[S.top] 3.**top--**

​	栈长：**S.top+1**

​	2.**共享栈**

​		栈顶指针(**初始**)：**top0=-1,top1=Maxsize**

​		进栈操作：1.**判断栈满(top1-top0=1)** ； **top0++** ; 赋值

 				   2.**判断栈满(top1-top0=1)** ； **top1--** ; 赋值

​		出栈操作：1.**判断栈空(top0==-1)** ； 赋值 ； **top0--**

​				   2.**判断栈空(top1==Maxsize)** ； 赋值 ； **top1++**

#### 3.1.3 链栈

​	采用链式存储的栈称为链栈，链栈的**优点**是便于**多个栈共享存储空间**和**提高其效率**，且**不存在栈满上溢**的情况。

​	**多个栈**一般采用链栈的方式。

#### 3.1.4 考点

​	n个不同元素进栈，出栈序列的数量

​	**卡特兰数**：
$$
\frac{1}{n+1} C ^{n} _{2n}=\frac{1}{n+1} \frac{(2n)!}{n!*n!}
$$
​	若X_i已经出栈，则前面尚未出栈的元素一定逆置有序的出栈。

### 3.2 队列

#### 3.2.1 队列的基本概念

​	队列也是一种操作受限的线性表，先进先出(FIFO)。

#### 3.2.2 队列的顺序存储结构

​	1.顺序队列

​		**队头指针**（front）:指向**队头元素**

​		**队尾指针**（rear）:指向**队尾元素的下一个位置**

​		**初始状态（队空条件）**：**Q.front=Q.rear=0**

​		**进队操作**：判断**队满**，赋值，**rear++**

​		**出队操作**：判断**队空**，赋值，**front++**

​		当front 和rear都在结尾时，再次入队会出现溢出，这是**假溢出**，由此引出**循环队列**来**解决**这个问题。

​	2.**循环队列（重点）**

​		**初始状态**（**非**队空条件）：**Q.front=Q.rear=0**

​		**进队操作**：判断**队满**，赋值，Q.rear=(Q.rear+1)**%Maxsize**

​		**出队操作**：判断**队空**，赋值，Q.front=(Q.front+1)**%Maxsize**

​		**队列长度**：(Q.rear+**Maxsize**-Q.front)**%Maxsize**

​		判断队空，队满：

​				1.牺牲一个单元

​						**队满**条件：**(Q.rear+1)%Maxsize==Q.front**

​						**队空**条件：Q.front==Q.rear

​				2.增加表示元素个数的数据成员

​						队满条件：Q.front==Q.rear&&Q.size==Maxsize

​						队空条件：Q.front==Q.rear&&Q.size==0

​				3.类型中增加标志tag

​						队满条件:Q.front==Q.rear&&Q.tag==1

​							入队操作同时将tag置为1

​						队空条件:Q.front==Q.rear&&Q.tag==0

​							出队操作同时将tag置为0

#### 3.2.3 队列的链式存储结构

​	1.不带头节点的链式队列

​		队头指针：队头节点

​		队尾指针：队尾节点（**不同于顺序存储**）

​		初始状态：**Q.front=Q.rear=NULL**

​		入队操作：建立新节点s，rear->next=s，rear=rear->next(若为**第一个节点**，则**front=rear**)

​		出队操作：**判断队空**，取出队头元素,front=front->next(若**最后一个元素的删除**则置**front=rear=NULL**)

​		判断队空：Q.front**==**Q.rear**==NULL**（**仅等于无法判断**，只有一个元素也是等于）

​	2.带**头结点**的链式队列

​		**队头指针**：**头结点**

​		队尾指针：队尾节点

​		**初始状态**：**Q.front=Q.rear=head**

​		入队操作：建立新节点s，rear->next=s，rear=rear->next（**不用判断第一个节点**）

​		出队操作：**判断队空**，取出队头元素,front=front->next(若**最后一个元素的删除**则置**front=rear(非NULL**))

​		判断队空：Q.front**==**Q.rear(**不用判断NULL**,只有一个元素，front=head，rear不是)	

#### 3.2.4 双端队列

​	**输出受限**的双端队列：允许在**一端**进行**插入和删除**，另一端**只允许插入**

​	**输入受限**的双端队列：允许在**一端**进行**插入和删除**，另一端**只允许删除**

| **不能得到的** | 相同 | 不同 |
| -------------- | ---- | ---- |
| **输入受限**   | 4231 | 4213 |
| **输出受限**   | 4231 | 4132 |

​	**双端队列**的**可能序列**判断，在**中间画竖线**，**两边**方向**依次递增**。

​	列：b|acde,db|ace,ecb|ad	

### 3.3 栈的应用

#### 3.3.1.括号匹配

​			（1）遇到**左括号入栈**

​			（2）遇到**右括号出栈一个与它对比**，**不同则失败**

​			（3）**扫描完**时**栈为空**则**匹配**

#### 3.3.2**表达式求值**

| 转化           | 后缀表达式                                                   | 前缀表达式                                                   |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **中缀表达式** | 1.按优先级对所有运算单位加括号 <br />2.运算符移到括号**后面**<br />3.去括号 | 1.按优先级对所有运算单位加括号<br />2.运算符移到括号**前面**<br />3.去括号 |

​	注意不管哪种表达式，**变量的顺序不变**。

​	**后缀表示式**=**表达式树**的**后序遍历**

​			（1）**后缀表达式计算值**

​					依次扫描(**从左到右**)：

​							字母->入栈

​							符号->从栈中退出两个并计算，将计算结果入栈

​					栈顶为最后结果

​			（2）**前缀表达式计算值**

​					依次扫描(**从右到左**)：

​							字母->入栈

​							符号->从栈中退出两个并计算，将计算结果入栈(注意**计算次序**，基本原则是**字母顺序不变**)

​					栈顶为最后结果

​					练习：前缀表达式转中缀表达式：+-*^ABCD/E/F+GH

#### 3.3.3**栈在递归中的应用**

​			**递归**：在一个函数，过程或数据结构的定义中又应用了它本身。

​			**递归条件**：	**递归表达式**（递归体）

​						**边界条件**（递归出口）

​			递归的**精髓**在于能否将原始问题**转换**为**属性相同**但**规模较小**的问题。

​			**任何一个**递归算法**都可以**用**栈转换**，但是**不一定**要用**栈转换**。

### 3.4 队列的应用

#### 3.4.1 二叉树层次遍历（图广度遍历）

​	1.根结点入队

​		while(队列不空)

​				队列第一个结点出队

​				访问第一个节点（输出）

​				若有左孩子，左孩子入队

​				若有右孩子，右孩子入队

#### 3.4.2 计算机系统中的应用

​	1.解决主机与外部设备之间速度不匹配的问题

​			打印机，等外部设备

​	2.解决由多用户引起的资源竞争问题

​			CPU调度等

<div STYLE="page-break-after:always;"></div>

## 4. 树与二叉树

### 4.1 树的基本概念

​	树的结点数：N>=0,N=0时为空树

​	树适用于表示有**层次结构**的数据。

​	**N个结点**的树有**N-1条边**:   $N=n_1+n_2+n_3+...+n_m=n_1 *1 +n_2 *2+n_3*3+....+n_m*m+1$

​	树中结点的**最大度数**称为树的**度**

​	度>0的点称为**分支节点**，**度=0**的点称为**叶子节点（终端节点）**

​	结点层次：**根节点为1**

​	树的**高度（深度**）是树中结点的**最大层数**

​	**有序树**：结点的子树**从左到右**是**有次序**的，反之为**无序树**

​	**两个结点**的**路径**是由**这两个结点之间所经过的结点序列**构成的

​	**路径长度**是路径上所经过的**边的个数**

​	**树的路径长度**	是**从根结点到每一结点路径长度**的**总和**(不同于边的数量)

​	树中的相关性质（度为m）：

​			**第i层**：**至多**$m^{i-1}$个结点

​	(**重点**)	**按序号从上到下，每层从左到右编号满m叉树：**

​			则：**第 i 层节点数**：$m^{(i-1)}$

​				结点 i 的**第 k 个孩子**编号为：$(i-1)*m+1+k$    (前i-1个节点都有了m个孩子，再加上自己)

​				结点 i 的**双亲编号**为: $\lfloor(i-2)/m \rfloor +1$

|    m叉树     |                   至少                    |              至多               |
| :----------: | :---------------------------------------: | :-----------------------------: |
| 高度h->结点n |             $n_{min}=h+(m-1)$             | $n_{max}=\frac {(m^h-1)} {m-1}$ |
| 结点n->高度h | $h_{min}=\lceil log_m[n(m-1)+1]   \rceil$ |        $h_{max}=n-(m-1)$        |

​	 注意：**结点数=边+1**
$$
N=n_1+n_2+n_3+...+n_m=n_1 *1 +n_2 2+n_33+....+n_m*m+1
$$

​	任何一个树中的**叶子节点**数量为：$n_0=1+\sum^{m}_{i=1} (i-1)n_i $

​	**n个结点**构造的**不同的树**的数量:$Catalan(n-1)$

### 4.2 二叉树的概念

#### 4.2.1 二叉树的定义及主要特性

​	二叉树的**度>=2**

​	二叉树**可以**是**空树**

​	二叉树是**有序树**

​	对比**度为2的有序树**：

​			度为2的有序树不可以为空，且**最小结点数为3**

​			**二叉树**的结点次序**不是相对另一结点而言**，是确定的

​	**满二叉树**：

​				$n=2^h-1$

​				$n=2n_0-1$

​				根为i:**左孩子为2i,右孩子为2i+1**

​	**完全二叉树：**

​				$n_1=1或0$

​				$n=2n_0-1$或者$n=2n_0$

​	

| 完全二叉树                          | 至少            | 至多             |
| ----------------------------------- | --------------- | ---------------- |
| 高度h->结点n                        | $2^{(h-1)}$     | $2^h-1$          |
| 第 i 层有 <br />k 个叶子结点->结点n | $2^{(i-1)}-1+k$ | $2^{(i+1)}-2k-1$ |

​	**二叉树性质**：

​				$n_0=n_2+1$

​				**第k层至多**$2^{k-1}$

​				**n个结点**构造的**不同的二叉树**的数量:$Catalan(n)$

|    二叉树    |                             至少                             |      至多       |
| :----------: | :----------------------------------------------------------: | :-------------: |
| 高度h->结点n |                         $n_{min}=h$                          | $n_{max}=2^h-1$ |
| 结点n->高度h | $h_{min}=\lceil log_2(n+1)  \rceil$<br />或$\lfloor log_2n \rfloor+1$ |   $h_{max}=n$   |

​	n个结点的二叉树有**n+1个空链域**

#### 4.2.2 二叉树的存储结构

​	**顺序存储结构**：将编号为i的节点元素存储到数组下标为i-1的分量中

​					完全二叉树和满二叉树适合用来存储。

​	**链式存储结构**：分为**数据域，左指针域和右指针域**。

### 4.3 二叉树的遍历和线索二叉树

#### 4.3.1 二叉树的遍历

​	遍历：**先序遍历**，**中序遍历，后序遍历**

​	三种遍历方式的**时间复杂度**都是**O(n)**,**空间复杂度**都是**O(n)**.

​	三种遍历方法中**叶子节点**的**遍历先后顺序**都是**固定**的。

​	可以用**后序遍历**找到**祖先的路径**

​	前序序列和中序序列的关系是以**前序序列**为**入栈次序**，**中序序列**为**出栈顺序**（卡特兰数）

| 形态       | 相同    | 相反             |
| ---------- | ------- | ---------------- |
| 先序，后序 | 只有根  | $N_0=1（N_2=0）$ |
| 先序，中序 | $N_L=0$ | $N_R=0$          |
| 中序，后序 | $N_R=0$ | $N_L=0$          |
| 先序，层次 | $N_2=0$ | 只有根或空树     |
| 中序，层次 | $N_L=0$ | $N_R=0$          |
| 后序，层次 | $N_2=0$ | $N_0=0$          |

ssr	**二叉树的非递归遍历（见习题）**。

​	**二叉树的层次遍历(同图的广度遍历)**，需要**借助队列**。

​	由**遍历序列构造二叉树**：（见习题）

​					1.**先序序列+中序序列**

​					2.**后序序列+中序序列**

​					3.**层次序列+中序序列**

​		**前序序列**和**后序序列不能唯一确定二叉树**，但是可以**确定节点的祖先关系**，**前序**序列为**XY**与**后序**序列为**YX**时（**两者相邻**！），**X为Y的祖先**。

#### 4.3.2 线索二叉树

​	1.**概念**

​	线索二叉树是个**物理结构**

​	实质就是对一个**非线性结构进行线性化操作**

​	每个线索二叉树都有**n+1**个线索（每个树都有n+1个空指针）

​	**线索化**后的**空的链域**为：

| 线索化后空链域数 |       1        |      2       |
| ---------------- | :------------: | :----------: |
| **先序**线索树   | 根左子树不为空 | 根左子树为空 |
| **中序**线索树   |     不存在     |      =       |
| **后序**线索树   | 根右子树不为空 | 根右子树为空 |

​	引入线索二叉树是**为了加快查找结点前驱**和**后继**的**速度**。

​	二叉树线索化时：若**无左子树（ltag=1**）,令**lchild指向前驱**节点。

​					若**无右子树（rtag=1**）,令**rchild指向前驱**节点。

​	带**头节点**的线索二叉树：

​			线索化后**空的链域为0**

​			头节点**左孩子**为**根节点**，**右孩子**为**最后访问的节点**

​			序列的**第一个节点**的**左孩子**和**最后一个节点**的**右孩子**指向**头节点**

​	中序线索树的前驱后继容易求出（左孩子最右边，右孩子最左边）。

​	**先序线索树**的**后继**容易求出，但是**前驱必须知道双亲**（栈存取），前序线索树的**遍历不需要栈**的支持。

​	**后序线索树**的**后继**不能求出，**必须知道双亲**（栈存取），后序线索树的**遍历**需要**栈**的支持(**一般**)。

​	注：**并非所有**后序线索树遍历**都要用栈**，比如**任何结点最多只有左子树**的后序线索树就不需要。



**不是每个节点**都可以**通过线索**找到它的**前驱和后继**，**先序线索树**的**前驱**必须**知道双亲**，**后序线索树**的**后继**必须知道**双亲**。

### 4.4 树，森林

#### 4.4.1 树的存储结构

​	1.**双亲表示法**

​		采用一组**连续空间**来存储每个结点（类数组），**伪指针域**为**-1（无双亲）**或者指向**双亲结点下标**。

​		可以**很快**得到每个结点的**双亲**结点，但是求**孩子**结点需要**遍历整个结构**。

​	2.**孩子表示法（手绘）**

​		将**每个结点**的**孩子结点**都用**单链表链接**起来。

​		找**子女**非常**直接**，寻找**双亲**需要**遍历N个节点中孩子链表指针域所指向的N个孩子链表**。

​	3.**孩子兄弟表示法（手绘）**

​		又称**二叉树表示法**

​		**二叉链表**作为存储结构         |指向**第一个孩子结点**的指针|**结点值**|**下一个兄弟结点**的指针

​		方便实现**树转二叉树**的操作，**易于查找孩子**。

​	注：**森林**中有**n个结点b条边**，则**森林**中共有**n-b棵树**。

#### 4.4.2 树，森林与二叉树的转换

​	**左孩子右兄弟**。

​	**森林F->二叉树B**：	

​					***B中无右孩子结点数=F中非叶节点数+1**

​					***F中叶结点数=B中无左孩子结点数**

#### 4.4.3 树和森林的遍历

​	**树的遍历**：

​			**先根遍历**：先访问**根结点**，再依次**先根遍历子树**。

​			**后根遍历**：顺序**后根遍历**子树，再访问**根节点**。

​	**森林的遍历**：

​			**先序遍历**：1.访问森林中第一棵树的根节点  

​					   2.先序遍历第一棵树中根节点的子树森林

​					   3.先序遍历除去第一棵树之后剩余的树构成的森林

​			***中序遍历**：1.中序遍历森林中第一棵树的根节点的子树森林

​					   2.访问第一棵树的根节点

​					   3.中序遍历除去第一棵树之后剩余的树构成的森林

| 树           | 森林         | 二叉树       |
| ------------ | ------------ | ------------ |
| **先根遍历** | **先序遍历** | **先序遍历** |
| **后根遍历** | **中序遍历** | **中序遍历** |

| 森林（树） F | 二叉树 B             |
| ------------ | -------------------- |
| $F_0$        | $B_R+B_0$            |
| $F-F_0$      | $B_L+B_0-1(B_L+B_2)$ |

​	其中 $B_1=B_L+B_R$,$B_L$代表只有左子树的节点个数，$B_R$代表只有右子树的节点个数。

#### 4.4.4 并查集

#### 4.4.5 哈夫曼树 哈夫曼编码

​	**WPL** 树的带权路径长度是指树中的所有的叶子节点的带权路径的长度之和

​	**哈夫曼树的特点**

​		权值越大的节点 离根节点越近

​		树中没有度为**1**的节点

​		树的带权路径最短 

​	**哈夫曼编码**

​		任一字符的编码串都不是另一字符编码的前缀串的前缀

​		根通往任一叶子节点的路径都不可能是通往其余叶子节点路径的子路径

​	**哈夫曼N叉树**

​		构造方法同二叉树类似

​		度为m的哈夫曼树中，叶子节点个数为n，则非叶子节点的个数为 (n-1)/(m-1)

<div STYLE="page-break-after:always;"></div>

## 5. 图

#### 5.1 图的基本概念

图 : 图是由**有穷**并且**非空**的集合V和边的集合E组成。

​	图中可以一条边都没有，但是至少需要一个顶点。

**图的标记**：
$$
图：G(V,E)\\
顶点集：V(G) \quad 顶点数量：|V|(\ge 1)\\
边集：E(G)\quad 边数量:|E|
$$
**无向图**：

​	概念：每条边都**无方向**

​	**度**：与**该顶点**相关的**边的条数**	$\sum _{i=1}^n TD(V_i)=2e$（常用于计算）

​	**无向完全图**：图中**任意两个顶点**之间**都存在边**。即$|V|=n$时$|E|=\frac {n(n-1)}{2}$

​	**连通图**：在**无向图**中，图中**任意两个顶点**之间都**存在路径（连通）**

​			图中的**极大连通子图（即任意增加G中的结点或边后所得到的G的子图都不再连通）**称为**连通分量**。

**有向图**：

​	概念：每条边都**有方向**,由1指向2表示为$<1,2>$

​	**出度**：由**该顶点发出**的**边的条数**		$\sum _{i=1} ^n ID(V_i)=e$

​	**入度**：**指向该顶点**的**边的条数**		$\sum _{i=1} ^n OD(V_i)=e$

​	**有向完全图**：图中**任意两个顶点**之间**都存在方向相反的两条弧**。即$|V|=n$时$|E|=n(n-1)$

​	**强连通图**：在**有向图**中，对于图中的**任意一对顶点**之间都存在**相互的路径（强连通）**

​			   其中的**极大强连通子图**称为**强连通分量**

**子图**：**并非**所有点和边的子集都可以组成子图，**需要边对应点**。

**生成树**：包含图中**所有顶点**的一个**极小连通子图**。

​		n个顶点的**环**有n个**生成树**。

**路径**和**路径长度**：**路径**为**相邻顶点序偶**所构成的**序列** **路径长度**是指路径上**边的数目**

**简单路径**:**顶点不重复**出现的路径

**回路**：路径中**第一个顶点**和**最后一个**顶点**相同**的路径

​		**环（回路）判断**方式：**深度优先遍历**

​							**拓扑排序**

​							**关键路径（前提拓扑排序）**

**稠密**图：边数**多**的图	**稀疏**图：边数**少**的图

n个顶点的图的性质：

|            |     有环的最少边数     |       必有环的边数       |
| :--------: | :--------------------: | :----------------------: |
| **无向图** |           3            |            n             |
| **有向图** |           2            |            n             |
|            | **(强)连通的最少边数** |   **必(强)连通的边数**   |
| **无向图** |       n-1（树）        | $\frac{(n-1)(n-2)}{2}+1$ |
| **有向图** |        n（环）         |       (n-1)(n-2)+1       |

#### 5.2 图的储存结构

##### 5.2.1邻接矩阵

邻接矩阵的结构型 定义如下

```c
typedef struct {
    int no;            //顶点编号
    char info;         //顶点信息
}VertexType;           //顶点类型

typedef struct{
    int edges[maxsize][maxsize];  //邻接矩阵定义
    int N,E;                      //N 定点数  E 边数
    VertexType vex[maxsize];      //存放结点信息
}MGraph;               
```

**无向图：**

​		**邻接矩阵**为**对称矩阵**。

​		第i**行**非0元素数量和=第i**列**元素和=$TD(V_i)$

**有向图**：

​		第i**行**的**非0元素**数量和=$OD(V_i)$

​		第i**列**的**非0元素**数量和=$ID(V_i)$

**无向图**的**邻接矩阵**是**对称**矩阵

**邻接矩阵**表示**唯一**。

**$A^m[i][j]$：从**顶点 i** 到**顶点 j** 长度为 **m** 的**路径长度**

##### 5.2.2邻接表

结构型定义如下：

```c
typedef struct ArcNode{
    int adjvex; //所指向结点的位置
    struct ArcNode *nextArc; //下一条边的指针
    int info;   //边的相关信息
}ArcNode;      //边的定义

typedef struct{
    char data;  //顶点信息
    ArcNode *firstarc; //该顶点指向的第一条边的指针
}VNode;        //顶点

typedef struct{
    VNode adjlist[maxsize];
    int n,e;
}AGraph;     //图的定义
```

**有向图：**

​		**出度**：**结点个数**

​		**入度**：需要**遍历**全部邻接表

图的**邻接表**表示**不唯一**。

|                |  邻接矩阵  |  邻接矩阵  |    邻接表     |     邻接表      |
| -------------- | :--------: | :--------: | :-----------: | :-------------: |
|                | **无向图** | **有向图** |  **无向图**   |   **有向图**    |
| **特性**       |  对称矩阵  |            |               |                 |
| **出度**       | i行(列)和  | i**行**和  |   边表个数    |    边表个数     |
| **入度**       | i行(列)和  | i**列**和  |   边表个数    | 边表结点为i的和 |
| **边数**       | 1的个数/2  |  1的个数   | 边结点个数/2  |   边结点个数    |
| **边相连**     | $A[i][j]$  | $A[i][j]$  |     边表      |      边表       |
| **空间复杂度** | $O(|V|^2)$ | $O(|V|^2)$ | $O(|V|+2|E|)$ |  $O(|V|+|E|)$   |
| **适用**       |   稠密图   |   稠密图   |    稀疏图     |     稀疏图      |

#### 5.3 图的遍历算法操作

​	**图的遍历**是指从图中的**某一顶点**出发（**非连通图**可能一个顶点不足以访问全部），按照某种搜索方法对所有顶点访问一次且**仅访问一次**。

##### 5.3.1 广度优先遍历（BFS）

​	广度优先遍历**不是**一个**递归**算法

​	**方法**：

​			1.首先将根节点放入队列中

​			2.从队列中取出第一个节点，并检验它是否为目标

​				*如果找到目标，则结束搜索并回传结果

​				*否则将它所有尚未检验过的直接子节点加入队列中

​			3.若队列为空，表示整张表都检查过了

以**邻接表**为储存结构的算法如下：

```c
int visit[maxsize];

void BFS(AGraph *G,int v)
{
    ArcNode *p;
    int que[maxsize],front=0,rear=0;
    int j;
    visit[v] = 1;
    Visit(v);
    rear = (rear+1)%maxsize;
    que[rear] = v;                    //V入队
    while(front!=rear)
    {
        front = (front+1)%maxsize;
        j = que[front];               //顶点出队
        p = G->adjlist[j].firstarc;
        while(p!=NULL)
        {
            if(visit[p->adjvex]==0)
            {
                visit[p->adjvex] = 1;       //邻接顶点访问并入队
                Visit(p->adjvex);
                rear = (rear+1)%maxsize;
                que[rear] = p->adjvex;
            }
            p=p->nextarc;
        }
    }
}

void bfs(AGraph *g)
{
    int i;
    for(i=0;i<g->n;i++)
        if(visit[i]==0)
            BFS(g,i);
}
```

​	**BFS**算法可以用来解决**权值相等的图**的**单源最短路径**问题（注意权值不等不可）。

​	**广度优先生成树**：

​					用**邻接矩阵**表示的图的**广度**优先生成树是**唯一**的。

​					用**邻接表**表示的图的**广度**优先生成树是**不唯一**的。

##### 5.3.2深度优先遍历（DFS）

​	深度优先搜索是一个**递归**算法

```c
//以邻接表为储存结构的递归算法如下：
int visit[maxsize];//全局变量 标记数组

void DFS(AGraph *G,int v) //从结点V开始的遍历
{
    AGraph *p;
    visit[v] = 1;     //置已访问标记
    Visit(v);         //访问节点
    p = G->adjlist[v].firstarc;   //指向顶点v的第一条边
    while(p!=NULL)
    {
        if(visit[p->adjvex]==0)   //未访问 则递归访问他
            DFS(G,p->adjvex);
        p = p->nextarc;           //下一条边继续
    }
}

//以邻接矩阵为储存结构的递归算法如下：
int visit[maxsize];//全局变量 标记数组

void DFS(MGraph *G,int v) //从结点V开始的遍历
{
    visit[v] = 1;     //置已访问标记
    Visit(v);         //访问节点
	int i;
    for(i=0;i<G->n;i++)
    {
        if(G->adges[v][i]>0 && visit[i]==0)
            DFS(G,i);
    }
}
```

​	以**邻接表**为储存结构的非递归算法如下：

```c
int visit[maxsize];

void DFS(AGraph *G,int v)
{
    AGraph *p;
    int j;
    int stack[maxsize],top; //该栈用来暂存节点
    top = -1;             
    stack[++top] = v;       //起始节点入栈
    while(top!=-1)
    {
        j = stack[top--];   //取出栈顶节点
        visit[j] = 1;
        Visit(j);
        p = G->adjlist[j].firstarc;
        while(p!=NULL)
        {
			if(visit[p->adjvex]==0)
                stack[++top] = p->adjvex;
            p = p->nextarc;
        }
    }
}

void dfs(AGraph *g)
{
    int i;
    for(i=0;i<g->n;i++)
        if(visit[i]==0)
            DFS(g,i);
}
```

**DFS**用来解决图中的**回路存在**问题：

​			**无向图**：DFS过程中遇到了**回边**必定存在环。

<<<<<<< HEAD
```c
//以邻接表为储存结构的算法如下：
int visit[maxsize];
void BFS(AGraph *G,int v)
{
    ArcNode *p;
    int que[maxsize],front=0,rear=0;
    int j;
    visit[v] = 1;
    Visit(v);
    rear = (rear+1)%maxsize;
    que[rear] = v;                    //V入队
    while(front!=rear)
    {
        front = (front+1)%maxsize;
        j = que[front];               //顶点出队
        p = G->adjlist[j].firstarc;
        while(p!=NULL)
        {
            if(visit[p->adjvex]==0)
            {
                visit[p->adjvex] = 1;       //邻接顶点访问并入队
                Visit(p->adjvex);
                rear = (rear+1)%maxsize;
                que[rear] = p->adjvex;
            }
            p=p->nextarc;
        }
    }
}

void bfs(AGraph *g)
{
    int i;
    for(i=0;i<g->n;i++)
        if(visit[i]==0)
            BFS(g,i);
}

//以邻接矩阵为储存结构的算法如下：
int visit[maxsize];
void BFS(MGraph *G,int v)
{
    int que[maxsize],front=0,rear=0;
    int j;
    visit[v] = 1;
    Visit(v);
    rear = (rear+1)%maxsize;
    que[rear] = v;                    //V入队
    while(front!=rear)
    {
        front = (front+1)%maxsize;
        j = que[front];               //顶点出队
        for(int i=0;i<G->n;i++)
        {
            if(G->adges[j][i]>0&&visit[i]==0)
            visit[i] = 1;       //邻接顶点访问并入队
            Visit(i);
            rear = (rear+1)%maxsize;
            que[rear] = i;
        }
    }
}
```
=======
​			**有向图**：若在一次**从一结点出发**的遍历**结束之前**碰到**该节点**，则存在环。

**DFS**遍历一个**无环有向图**，在**退出递归**时输出其**逆拓扑有序序列**（退出递归时是逆是因为其栈性质，否则不逆）

**深度度优先生成树**：

​					用**邻接矩阵**表示的图的**深度**优先生成树是**唯一**的。

​					用**邻接表**表示的图的**深度**优先生成树是**不唯一**的。

##### 5.3.3 DFS和BFS总结

|                 | 对应树遍历 | 借助结构 | 时间复杂度                                     | 空间复杂度 |
| --------------- | ---------- | -------- | ---------------------------------------------- | ---------- |
| **广搜（BFS）** | 层次遍历   | 队列     | 邻接矩阵：$O(|V|^2)$<br />邻接表：$O(|V|+|E|)$ | $O(V)$     |
| **深搜（DFS）** | 先序遍历   | 栈       | 邻接矩阵：$O(|V|^2)$<br />邻接表：$O(|V|+|E|)$ | $O(V)$     |

对于同一个图，基于**邻接矩阵**的遍历所得的DFS序列和BFS序列是**唯一**的，而**邻接表**的遍历得到的序列是**不唯一**的（**具体给出物理存储结构是唯一的**）。

**无向图**：	**连通**：从**任一节点**出发，则仅需一次便可遍历**所有**结点。

​		**非连通**：**任一节点**一次遍历只能遍历其该**连通分量**的顶点。
>>>>>>> 0db9edcc4edd5b7c287c93a0ea1de84f8a74f78b

**有向图**：**强连通**：**任一节点**开始可以一次遍历**所有**结点。

​		**非强连通**：**任一节点**一次**无法**遍历其**连通分量**。（若为**强连通分量**则可遍历该**强连通分量**）

使用**标号法**判断遍历序列是否合法。

**深度**优先生成树**高**>=**广**度优先生成树**高**

#### 5.4最小代价生成树  

（**普里姆算法和科鲁斯卡算法都是针对于无向图的**）

最小生成树：

​	**最小生成树**是图的**极小连通子图**（**并非连通分量**），包含图中所有顶点，只包含尽可能少的边，若砍去它的一条边，则变成非连通图，若增加一条边，则形成一条回路。

​	性质：

​			1.最小生成树**不是唯一**的，只有当**各边的权值互不相等时唯一**，当边为n-1时，就是其本身。

​			    或者有相等的边，但是在构造最小生成树的过程中权值相等的边都被并入生成树的图

​			2.最小生成树的**权值之和**总是**唯一**的。

​			3.最小生成树的**边数**为**顶点数减一**。

​			4.若(u,v)是一条具有最小权值的边，其中$u\in U,v\in V-U$,则必存在一颗包含这条边的最小生成树。

##### **5.4.1普里姆算法（加点法）：**

以邻接矩阵为储存结构

```c
void Prim(MGraph g,int v0,int &sum)
{
    int lowcost[maxsize],vset[mexsize],v;
    int i,j,k,min;
    v = v0;
    for(i=0;i<g.n;i++)              //初始化lowcost数组
    {
        lowcost[i] = g.edges[v0][i];
        vset[i] = 0;
    }
    vset[v] = 1;                   //把V0并入到树中
    sum = 0;                       //sum用来累计树的权值
    for(i=0;i<g.n-1;i++)
    {
        min = INF; 
        //选出候选边的最小值
        for(j=0;j<g.n;j++)
        {
            if(vset[j]==0&&lowcost[j]<min)
            {
                min = lowcost[j];
                k = j;
            }
        }
        v = k;
        sum += min;               //记录了最小生成树的权值
        //更新候选边
        for(j=0;j<g.n;j++)
        {
            if(vset[j]==0&&g.edges[v][j]<lowcost[j])
                lowcost[j] = g.edges[v][j];
        }
    }
}
```

##### **5.4.2科鲁斯卡算法（加边法）:**

算法思想：选出权值最小的边 （并检测该边的并入是否会造成回路）然后将该边并入到当前生成树中

代码实现: （要用到并查集）

同样也是借助邻接矩阵来实现的

```c
typedef struct
{
    int a,b;             //一条边所依附的两个顶点
    int w; 				 //一条边所对应的权值
}Road;                   //边的定义
Road road[maxsize];
int v[maxsize];          //声明并查集数组
int getRoot(int a)       //查找并查集中根节点的函数
{
    while(a!=v[a])
        a = v[a];
    return a;
}

void Kruskal(MGraph g,int &sum,Road road[])    //传入的road数组中已经包含路径信息
{
    int i;
    int N,E,a,b;
    N = g.n; E = g.e;
    sum = 0;      //初始化清零
    //并查集的初始化
    for(i=0;i<N;i++) v[i] = i;
    sort(road,E);           //对road数组中的E条边按照权值从小到大排列
    for(i=0;i<E;i++)
    {
        a = getRoot(road[i].a);
        b = getRoot(road[i].b);
        if(a!=b)          //这条边的并入并不会导致环
        {
            v[a] = b;
            sum+=road[i].w;
        }
    }
}
```

##### 5.5.3 总结

|         | 时间复杂度     | 适用范围 |
| ------- | -------------- | -------- |
| Prim    | $O(|V|^2)$     | 稠密图   |
| Kruskal | $O(|E|log|E|)$ | 稀疏图   |

#### 5.5最短路径

​	**权值相等**的图或者**无权图**可以用**广度优先**搜索。

​	带权图都可以使用以下两种求法。

​	两点之间的最短路径也包含了路径上其它顶点间的最短路径。（动态规划：最优子结构）

##### 5.5.1迪杰斯特拉算法（单源最短路径）

算法思想：设两个顶点集合 S(已找到的最短路径顶点) T(未找到的最短路径顶点)  初始时 S中只含有初始顶点v0 然后不断从集合T中选取到V0的路径长度最短的顶点Vu 并入到S中 S每并入一个新顶点 都要修改V0到集合T中各顶点的最短路径长度值 不断重复此过程 直到T为空

算法实现

同样也是借助于邻接矩阵

```c
void Dijkstra(MGraph g,int v,int dist[],int path[])
{
    int set[maxsize];
    int min,i,j,u;
    //对各数组进行初始化
    for(i=0;i<g.n;i++)
    {
        dist[i] = g.edges[v][i];
        set[i] = 0;
        if(g.edges[v][i]<INF)
            path[i] = v;     
        else
            path[i] = -1;
    }
    set[v] = 1;path[v] = -1; //把V加入set数组中
    for(i=0;i<g.n-1;i++)
    {
        min = INF;
        //每次从剩余顶点中选取一个通往该点路径是所有剩余顶点中最短的
        for(j=0;j<g.n;j++)
        {
            if(set[j]==0&&dist[i]<min)
            {
                u = j;
                min = dist[j];
            }
        }
        set[u] = 1;       //加入最短路径
        //更新dist
        for(j=0;j<g.n;j++)
        {
            if(set[j]==0&&dist[u]+g.edges[u][j]<dist[j])
            {
                dist[j] = dist[u]+g.edges[u][j];
                path[j] = u;
            }
        }
    }
}

//打印最短路径
void PrintPath(int path[],int a)      //由V到a的最短路径
{
    int stack[maxsize],top = -1;
    while(path[a]!=-1)
    {
        stack[++top] = a;
        a = path[a];
    }
    stack[++top] = a;
    while(top!=-1)
        print(stack[top--]);
}
```

##### 5.5.2弗洛伊德算法

```c
//算法思想如下: 借助邻接矩阵实现

//1)设置两个矩阵 A 和 Path 初始时把图的邻接矩阵赋值给A 把Path中元素全部设置为-1

//2)以顶点K（K取0~n-1）作为中间顶点 对图中所有顶点做如下修改：
//	if A[i][j]>A[i][k]+A[k][j] 
//  {
//		A[i][j] = A[i][k]+A[k][j];path[i][j] = k
//  }
//  else 啥也不做;

void Floyd(MGraph h,int Path[][maxsize])
{
    int i,j,k;
    int A[maxsize][maxsize];
    for(i=0;i<g.n;i++)                  //初始化
        for(j=0;j<g.n;j++)
        {
            A[i][j] = g.edges[i][j];
            Path[i][j] = -1;
        }
    //以K为中间节点对所有顶点对进行修改检测
    for(k=0;k<g.n;k++)
    	for(i=0;i<g.n;i++)
            for(j=0;j<g.n;j++)
                if(A[i][k]+A[k][j]<A[i][j])
                {
                    A[i][j] = A[i][k]+A[k][j];
                    Path[i][j] = k;
                }
}

//路径的打印算法
void PrintPath(int u,int v,int Path[][maxsize]) //输出U到V的最短路径序列
{
    if(Path[u][v] == -1)           //U到V有直接顶点
    {
        cout<<"("<<u<<","<<v<<")"<<;
    }
    else
    {
        int mid = Path[u][v];
        PrintPath(u,mid,Path);
        PrintPath(mid,v,Path);
    }
}
```

##### 5.5.3 总结

|          | 求解问题       | 时间复杂度 | 适用范围                   |
| -------- | -------------- | ---------- | -------------------------- |
| Dijkstra | 单源最短路径   | $O(|V|^2)$ | 不带负权值的图             |
| Floyd    | 各顶点最短路径 | $O(|V|^3)$ | 不包含带负权值的边组成回路 |

#### 5.6 拓扑排序

AOV网 ：简而言之就是活动在顶点上的网

**拓扑排序存在**：**必要**条件是该有向图**无环（回路）**，或者说成没有顶点数**大于1**的**强连通分量**。

​			   **充分**条件是该有向图邻接矩阵为**三角矩阵**。

**拓扑有序序列存在**：**充分必要**条件是**邻接矩阵**为**三角矩阵**

根据**唯一**的**拓扑排序**可以确定**多种**样式的**图**。

拓扑排序的核心算法：（真题中有过类似）

```c
//算法思想：
// 1）从有向图中选择一个入度为零的顶点输出
// 2）删除该顶点 并且删除从该顶点出发的全部边
// 3）重复上面两步 直到剩余的图中不存在没有前驱的顶点为止

//对邻接表表头结构做出相应调整
typedef struct
{
    char data;
    int count;    //count 用来统计入度
    ArcNode *firstarc;
}VNode;

//借助邻接表存储结构实现
int TopSort(AGraph *G)
{
    int i,j,n=0;
    int stack[maxsize],top=-1;
    ArcNode *p;
    for(i=0;i<G->n;i++)              //将入度为零的顶点入栈
        if(G->adjlist[i].count==0)
            stack[++top] = i;
    while(top!=-1)
    {
        i = stack[top--];            //顶点出栈
        ++n;
        cout<<i<<endl;
        p = G->adjlist[i].firstarc;
        while(p!=NULL)
        {
            j = p->adjvex;
            --(G->adjlist[j].count);
            if(G->adjlist[j].count==0)
                stack[++top] = j;
            p = p->nextarc;
        }
    }
    if(n==G->n)            //拓扑排序成功
        return 1;
    else                   //拓扑排序失败
        return 0;
}

//借助邻接矩阵存储结构实现
int TopSort(MGraph *G)
{
    int i,j,n=0;
    int stack[maxsize],top=-1;
    for(i=0;i<G->n;i++)              //将入度为零的顶点入栈
        if(G->vex[i].count==0)
            stack[++top] = i;
    while(top!=-1)
    {
        i = stack[top--];            //顶点出栈
        ++n;
        cout<<i<<endl;
        for(j=0;j<G->n;j++)
        {
            if(G->edges[i][j]>0)
            {
                G->vex[j].indegree--;
                if(G->vex[j].indegree==0)
                {
                    stack[++top] = j;
                }
            }
        }
    }
    if(n==G->n)            //拓扑排序成功
        return 1;
    else                   //拓扑排序失败
        return 0;
}

//拓扑排序后的序列可能并不唯一
```

求逆拓扑序列的方法也类似。。。另外 按照DFS算法的先后次序（即顶点退出系统栈的顺序）记录下的顶点序列即为逆向的拓扑有序序列

拓扑排序的算法复杂度为O(n+e);

(重点掌握手工进行拓扑排序的过程)

#### 5.7 关键路径

AOE网：活动在边上的网

在AOE网中 从源点到汇点的所有路径中具有**最大路径长度的路径**称为**关键路径**。

关键路径既代表了**最长路径** 又代表了整个工期所完成的**最短时间**

关键路径上的活动是关键活动，**关键活动一定在关键路径上**。

网中的**关键路径并不唯一**，只有加快**所有关键路径**上的活动才可减少时间。

具体步骤为：

​	1)根据图求出拓扑有序序列a 和 逆拓扑有序序列b

​	2)根据序列a求出最早发生时间 

​	   根据序列b求出最迟发生时间

​	3)求出每个活动的最早 最迟发生时间 

​	4)找出最早发生时间和最迟发生时间相同的活动 就是关键活动 由关键活动组成的路径就是关键活动

#### 5.8 练习

<<<<<<< HEAD

##### 5.8.1问答题

2.若一个有向图具有**拓扑排序序列** 那么他的邻接矩阵必定为**一般矩阵** 

证明：

4.证明具有n个顶点和多于n-1条边的无向连通图G一定不是树。

具有N-1个顶点 N-1条边的无向连通图是一棵没有确定根结点的树，每个结点均可以当根 若边数多于N-1时 因为一条边要连接两个顶点 则必因这一条边的加入 而使得两个结点多了一条通路 即形成回路

5.证明对有向图的顶点适当编号 可使其邻接矩阵为下三角且主对角线全为零的充要条件是该图为无环图

该有向图的顶点规律是弧尾顶点编号均大于弧头顶点编号 由于不存在从顶点出发并回到自身的弧 所以主对角线为0

充分性：因为该图是无环图 所以在进行适当编号后 必然存在弧尾顶点编号均大于弧头顶点编号的情况 所以上三角矩阵为0

必要性：若该图为无环图时 因为有回路 所以无论如何编号 必有弧头顶点大于弧尾顶点的存在  故必然为无环图

6.如何对有向图的顶点号重新安排 可使得该图的邻接矩阵中的1全部集中到对角线以上？

按照各顶点的出度进行排列 n个顶点的有向图 其顶点的最大出度是n-1 最小出度是0 这样排序后 出度最大的顶点编号为1 出度最小的编号为n   之后进行调整 即若存在弧《i，j》 其中顶点j的出度大于顶点i 则把j编号在i之前 变成《j,i》

7.邻接矩阵表示法 邻接表表示法 十字链表表示法 邻接多重表表示法的优缺点 1800 P136 16

8.导致得到的遍历序列不唯一的因素有哪些？

遍历的起始顶点不同 储存结构不同 在邻接表的情况下邻接点的顺序不同

9.对一个有向图 不用拓扑排序 怎样判断它是否有回路？

可采用深度优先遍历的方法 若从顶点V出发进行遍历 在DFS(v)结束之前出现从顶点W到顶点V的回边 因W是生成树上V的子孙 所以 该图必存在环。

<div STYLE="page-break-after:always;"></div>

## 6.查找

### 6.1 基本概念

​	平均查找长度：一次查找的长度是指需要比较的次数，平均查找长度则是所有查找过程中进行关键字的比较次数的平均值。
$$
ASL=\sum ^{n}_{i=1}P_iC_i
$$
​		其中，n是查找表的长度，Pi是查找第i个数据元素的概率，Ci是找到第i个数据元素所需进行的比较次数。

### 6.2 顺序查找和折半查找

​	**顺序查找：**
$$
C_i=i\qquad {成功}\\
ASL_{成功}=\sum ^{n}_{i=1}P_i(i)\\
P_i=\frac {1}{n}时，有ASL_{成功}=\frac{n+1}{2}\\
\qquad \\
C_i=n+1\qquad {失败}\\
ASL_{失败}=n+1
$$
​		对线性的**链表**只能**顺序查找**

​	**有序表的顺序查找：**

​		**查找成功**的**平均查找长度**和**一般线性表的顺序查找**一样。
$$
ASL_{成功}=\frac {n+1}{2}\\
ASL_{失败}=\sum _{j=1}^{n}q_j(l_j-1)=\frac{1+2+3+...+n+n}{n+1}=\frac{n}{2}+\frac{n}{n+1}
$$
​	**折半查找：**

​		仅适用于**有序**的顺序表,且只适合**顺序存储结构**，不适合链式。

​		**查找成功时**查找长度为从**根结点**到**目的结点**的**路径**上的**结点数**。

​		**查找失败时**查找长度为从**根结点**到对应**失败结点的父结点**的**路径**上的**结点数**。

​		每个判定树存在**n+1**个查找**失败结点**（对应空链域）。

​	算法：

​	非递归方式

```c
int B_Search(int L[],int key,int n)
{
    int low=0,high=n-1,mid;
    while(mid<=high)
    {
        mid=(low+high)/2;
        if(L[mid]==key)
        	return mid;
        else if(L[mid]>key)
       		high=mid-1;
        else
        	low=mid+1;
    }
    return -1;
}
```

​	递归方式

```c
int B_S(int L[],int key,int low,int high)
//初始时low为0，high为n-1
{
    int mid=(low+high)/2;
    if(L[mid]==key)
        return mid;
    else
        return (L[mid]>key)?B_S(L,key,low,mid-1):B_S(L,key,mid+1,high);
}
```

​	**分块查找**：

​		将序列分作b块，每块里面有n/b个元素。

​		**块内**元素是**无序**的，**块之间**是**有序**的。

​		在块间使用**顺序查找**：
$$
ASL_{成功}=L_I+L_S=\frac{b+1}{2}+\frac{\frac{n}{b}+1}{2}=\frac{b}{2}+\frac{n}{2b}+1
\\(ASL)'=0时，b=\sqrt {n} 
\\此时取最小
$$

​		在块间使用**折半查找**：
$$
ASL_{成功}=L_I+L_S=\lceil log_2(b+1)\rceil +\frac{1}{2}+\frac{n}{2b}
$$

<<<<<<< HEAD
| 平均查找长度   | 成功ASL_{成功}              | $ASL_{失败}$                |
| -------------- | --------------------------- | --------------------------- |
| 顺序查找       | \frac{n+1}{2}               | $n+1$                       |
| 有序表顺序查找 | $\frac{n+1}{2}$             | $\frac{n}{2}+\frac{n}{n+1}$ |
| 二分查找       | log_2(n+1)-1                |                             |
| 分块查找       | \frac{b+1}{2}+\frac{s+1}{2} |                             |
=======



| 平均查找长度   | $ASL_{成功}$                  | $ASL_{失败}$                |
| -------------- | ----------------------------- | --------------------------- |
| 顺序查找       | $\frac{n+1}{2}$               | $n+1$                       |
| 有序表顺序查找 | $\frac{n+1}{2}$               | $\frac{n}{2}+\frac{n}{n+1}$ |
| 二分查找       | $log_2(n+1)-1$                |                             |
| 分块查找       | $\frac{b+1}{2}+\frac{s+1}{2}$ |                             |
>>>>>>> 42519b27e80b70baac26ffb9f2866ba31caaa8d6

# 

















































































































































































































































## 7.排序

### 7.1 基本概念

稳定性：指当排序序列中有两个或者两个以上相同的关键字时，排序前后排序后这些关键字的相对位置如果没有发生变化就是稳定的，反之则不稳定。

**排序算法的分类：**

| 插入类的排序 | 交换类的排序 | 选择类的排序 | 归并类的排序 | 基数类排序 |
| ------------ | ------------ | ------------ | ------------ | ---------- |
| 直接插入排序 | 冒泡排序     | 简单选择排序 | 二路归并排序 | 基数排序   |
| 折半插入排序 | 快速排序     | 堆排序       |              |            |
| 希尔排序     |              |              |              |            |
|              |              |              |              |            |

### 7.2 插入类排序

#### 7.2.1直接插入排序

直接插入排序：每趟将一个待排序的关键字按照其值大小插入到已经有序的部分序列的合适位置上，直到所有关键字都被插入为止。

代码实现：

```c
void insertSort(int R[],int n)
{
    int i,j;
    int temp;
    for(i=1;i<n;i++)
    {
        temp = R[i];
        j = i-1;
        while(j>=0&&temp<R[j])
        {
            R[j+1] = R[j];
            --j;
        }
        R[j+1] = temp;
    }
}
```

算法复杂度分析：

最坏的情况：整个序列都是逆序的  所以基本操作次数为n(n-1)/2 时间复杂度为O(n^2)

最好的情况：整个序列都是正序的  双层循环变内层循环 时间复杂度为O(n)

平均的时间复杂度：O(n^2)

对于插入类的排序 一趟排序后并不能够确定任何一个关键字到达其最终位置

#### 7.2.2折半插入排序

折半插入排序：插入思想和直接插入排序相似，区别是折半插入是采用折半查找法来确定插入位置的

代码实现:

```c
//自己写的 仅供参考
void midInsert(int R[],int n)
{
    int low,high;
    low = 0;high = 0;
    int i,j,mid,temp;
    for(i=1;i<n;i++)
    {
        temp = R[i];
        while(low<=high)
        {
            mid = (low+high)/2;
            if(R[mid]>=R[i])
                high = mid-1;
            else 
                low = mid+1;
        }
        //插入到相应位置
        j = i-1;
        while(j>=low)
            R[j+1] = R[j];
        R[low] = temp;
        high++;
    }
}
```

与直接插入相比 折半插入在寻找插入位置上花的时间大大减少 在关键字移动次数上是一样的

时间复杂度 最坏情况是O(n^2)

​                    最好情况是O(nlogn)

​                    平均情况是O(n^2)                    